// node_modules/gophergfx/src/math/Color.ts
var _Color = class {
  constructor(r = 0, g = 0, b = 0, a = 1) {
    this.r = r;
    this.g = g;
    this.b = b;
    this.a = a;
  }
  set(r = 0, g = 0, b = 0, a = 1) {
    this.r = r;
    this.g = g;
    this.b = b;
    this.a = a;
  }
  copy(color) {
    this.r = color.r;
    this.g = color.g;
    this.b = color.b;
    this.a = color.a;
  }
};
var Color = _Color;
Color.WHITE = new _Color(1, 1, 1);
Color.BLACK = new _Color(0, 0, 0);
Color.RED = new _Color(1, 0, 0);
Color.GREEN = new _Color(0, 1, 0);
Color.BLUE = new _Color(0, 0, 1);
Color.YELLOW = new _Color(1, 1, 0);
Color.PURPLE = new _Color(1, 0, 1);
Color.CYAN = new _Color(0, 1, 1);

// node_modules/gophergfx/src/math/Vector2.ts
var _Vector2 = class {
  static copy(v) {
    return new _Vector2(v.x, v.y);
  }
  static inverse(v) {
    return new _Vector2(-v.x, -v.y);
  }
  static add(v1, v2) {
    return new _Vector2(v1.x + v2.x, v1.y + v2.y);
  }
  static subtract(v1, v2) {
    return new _Vector2(v1.x - v2.x, v1.y - v2.y);
  }
  static multiply(v1, v2) {
    return new _Vector2(v1.x * v2.x, v1.y * v2.y);
  }
  static divide(v1, v2) {
    return new _Vector2(v1.x / v2.x, v1.y / v2.y);
  }
  static multiplyScalar(v, n) {
    return new _Vector2(v.x * n, v.y * n);
  }
  static divideScalar(v, n) {
    return new _Vector2(v.x / n, v.y / n);
  }
  static distanceBetween(v1, v2) {
    return v1.distanceTo(v2);
  }
  static angleBetween(v1, v2) {
    return v1.angleBetween(v2);
  }
  static angleBetweenSigned(v1, v2) {
    return v1.angleBetweenSigned(v2);
  }
  static dot(v1, v2) {
    return v1.x * v2.x + v1.y * v2.y;
  }
  static normalize(v) {
    const sizeSquared = v.x * v.x + v.y * v.y;
    if (sizeSquared < 1e-8)
      return new _Vector2();
    const scaleFactor = 1 / Math.sqrt(sizeSquared);
    return new _Vector2(v.x * scaleFactor, v.y * scaleFactor);
  }
  static rotate(v, angle) {
    return new _Vector2(Math.cos(angle) * v.x - Math.sin(angle) * v.y, Math.sin(angle) * v.x + Math.cos(angle) * v.y);
  }
  constructor(x = 0, y = 0) {
    this.x = x;
    this.y = y;
  }
  set(x, y) {
    this.x = x;
    this.y = y;
  }
  copy(v) {
    this.x = v.x;
    this.y = v.y;
  }
  clone() {
    return new _Vector2(this.x, this.y);
  }
  equals(v) {
    return this.x == v.x && this.y == v.y;
  }
  add(v) {
    this.x += v.x;
    this.y += v.y;
  }
  subtract(v) {
    this.x -= v.x;
    this.y -= v.y;
  }
  multiply(v) {
    this.x *= v.x;
    this.y *= v.y;
  }
  divide(v) {
    this.x /= v.x;
    this.y /= v.y;
  }
  multiplyScalar(n) {
    this.x *= n;
    this.y *= n;
  }
  divideScalar(n) {
    this.x /= n;
    this.y /= n;
  }
  distanceTo(v) {
    return Math.sqrt(
      (this.x - v.x) * (this.x - v.x) + (this.y - v.y) * (this.y - v.y)
    );
  }
  setPositionFromMatrix(m) {
    this.x = m.mat[6];
    this.y = m.mat[7];
  }
  setScaleFromMatrix(m) {
    this.x = Math.sqrt(m.mat[0] * m.mat[0] + m.mat[1] * m.mat[1]);
    this.y = Math.sqrt(m.mat[3] * m.mat[3] + m.mat[4] * m.mat[4]);
  }
  applyMatrix(m) {
    const v = this.clone();
    const w = 1 / (m.mat[2] * v.x + m.mat[5] * v.y + m.mat[8]);
    this.x = w * (m.mat[0] * v.x + m.mat[3] * v.y + m.mat[6]);
    this.y = w * (m.mat[1] * v.x + m.mat[4] * v.y + m.mat[7]);
  }
  dot(v) {
    return this.x * v.x + this.y * v.y;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  normalize() {
    const sizeSquared = this.x * this.x + this.y * this.y;
    if (sizeSquared < 1e-8)
      return;
    const scaleFactor = 1 / Math.sqrt(sizeSquared);
    this.x *= scaleFactor;
    this.y *= scaleFactor;
  }
  invert() {
    this.x = -this.x;
    this.y = -this.y;
  }
  angleBetween(v) {
    const v1Norm = _Vector2.normalize(this);
    const v2Norm = _Vector2.normalize(v);
    return Math.acos(v1Norm.dot(v2Norm));
  }
  angleBetweenSigned(v) {
    const v1Norm = _Vector2.normalize(this);
    const v2Norm = _Vector2.normalize(v);
    return Math.atan2(v2Norm.y, v2Norm.x) - Math.atan2(v1Norm.y, v1Norm.x);
  }
  rotate(angle) {
    const x = this.x;
    const y = this.y;
    this.x = Math.cos(angle) * x - Math.sin(angle) * y;
    this.y = Math.sin(angle) * x + Math.cos(angle) * y;
  }
};
var Vector2 = _Vector2;
Vector2.ZERO = new _Vector2(0, 0);
Vector2.ONE = new _Vector2(1, 1);
Vector2.UP = new _Vector2(0, 1);
Vector2.DOWN = new _Vector2(0, -1);
Vector2.LEFT = new _Vector2(-1, 0);
Vector2.RIGHT = new _Vector2(1, 0);
Vector2.X_AXIS = _Vector2.RIGHT;
Vector2.Y_AXIS = _Vector2.UP;

// node_modules/gophergfx/src/math/MathUtils.ts
var MathUtils = class {
  static degreesToRadians(degrees) {
    return degrees * Math.PI / 180;
  }
  static radiansToDegrees(radians) {
    return radians * 180 / Math.PI;
  }
  static rescale(value, min, max, scaledMin, scaledMax) {
    return scaledMin + (scaledMax - scaledMin) * (value - min) / (max - min);
  }
  static clamp(value, min, max) {
    return Math.max(min, Math.min(max, value));
  }
};

// node_modules/gophergfx/src/core/Renderer.ts
var Viewport = /* @__PURE__ */ ((Viewport2) => {
  Viewport2[Viewport2["FIT"] = 0] = "FIT";
  Viewport2[Viewport2["CROP"] = 1] = "CROP";
  Viewport2[Viewport2["STRETCH"] = 2] = "STRETCH";
  return Viewport2;
})(Viewport || {});
var Renderer = class {
  constructor() {
    this.gfxCanvas = document.getElementById("gfxCanvas");
    if (!this.gfxCanvas) {
      alert("Unable to find gfxCanvas.");
    }
    this.gfxCanvas.width = window.innerWidth;
    this.gfxCanvas.height = window.innerHeight;
    const gl = this.gfxCanvas.getContext("webgl2", { alpha: false });
    if (!gl) {
      alert("Unable to initialize WebGL. Your browser or machine may not support it.");
    }
    this.gl = gl;
    gl.enable(gl.DEPTH_TEST);
    gl.depthFunc(gl.LEQUAL);
    gl.enable(gl.CULL_FACE);
    gl.cullFace(gl.BACK);
    gl.enable(this.gl.BLEND);
    gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
    this.background = new Color();
    this.viewport = 0 /* FIT */;
  }
  resize(width, height, aspectRatio) {
    this.gfxCanvas.width = width;
    this.gfxCanvas.height = height;
    if (this.viewport == 0 /* FIT */) {
      if (aspectRatio > window.innerWidth / window.innerHeight) {
        this.gl.viewport(
          0,
          (window.innerHeight - window.innerWidth / aspectRatio) / 2,
          window.innerWidth,
          window.innerWidth / aspectRatio
        );
      } else {
        this.gl.viewport(
          (window.innerWidth - window.innerHeight * aspectRatio) / 2,
          0,
          window.innerHeight * aspectRatio,
          window.innerHeight
        );
      }
    } else if (this.viewport == 1 /* CROP */) {
      if (aspectRatio > window.innerWidth / window.innerHeight) {
        this.gl.viewport(
          (window.innerWidth - window.innerHeight * aspectRatio) / 2,
          0,
          window.innerHeight * aspectRatio,
          window.innerHeight
        );
      } else {
        this.gl.viewport(
          0,
          (window.innerHeight - window.innerWidth / aspectRatio) / 2,
          window.innerWidth,
          window.innerWidth / aspectRatio
        );
      }
    } else {
      this.gl.viewport(
        0,
        0,
        window.innerWidth,
        window.innerHeight
      );
    }
  }
  render(scene, camera) {
    if (camera.projectionMatrixDirty) {
      this.resize(this.gfxCanvas.width, this.gfxCanvas.height, camera.getAspectRatio());
      camera.projectionMatrixDirty = false;
    }
    this.gl.clearColor(this.background.r, this.background.g, this.background.b, this.background.a);
    this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT);
    scene.draw(camera);
  }
  getNormalizedDeviceCoordinates(mouseX, mouseY) {
    const viewport = this.gl.getParameter(this.gl.VIEWPORT);
    return new Vector2(
      MathUtils.clamp((mouseX - viewport[0]) / viewport[2] * 2 - 1, -1, 1),
      MathUtils.clamp((mouseY - viewport[1]) / viewport[3] * -2 + 1, -1, 1)
    );
  }
};

// node_modules/gophergfx/src/math/Vector3.ts
var _Vector3 = class {
  static copy(v) {
    return new _Vector3(v.x, v.y, v.z);
  }
  static inverse(v) {
    return new _Vector3(-v.x, -v.y, -v.z);
  }
  static add(v1, v2) {
    return new _Vector3(v1.x + v2.x, v1.y + v2.y, v1.z + v2.z);
  }
  static subtract(v1, v2) {
    return new _Vector3(v1.x - v2.x, v1.y - v2.y, v1.z - v2.z);
  }
  static multiply(v1, v2) {
    return new _Vector3(v1.x * v2.x, v1.y * v2.y, v1.z * v2.z);
  }
  static divide(v1, v2) {
    return new _Vector3(v1.x / v2.x, v1.y / v2.y, v1.z / v2.z);
  }
  static dot(v1, v2) {
    return v1.x * v2.x + v1.y * v2.y + v1.z * v2.z;
  }
  static cross(v1, v2) {
    return new _Vector3(
      v1.y * v2.z - v1.z * v2.y,
      v1.z * v2.x - v1.x * v2.z,
      v1.x * v2.y - v1.y * v2.x
    );
  }
  static multiplyScalar(v, n) {
    return new _Vector3(v.x * n, v.y * n, v.z * n);
  }
  static divideScalar(v, n) {
    return new _Vector3(v.x / n, v.y / n, v.z / n);
  }
  static normalize(v) {
    const sizeSquared = v.x * v.x + v.y * v.y + v.z * v.z;
    if (sizeSquared < 1e-8)
      return new _Vector3();
    const scaleFactor = 1 / Math.sqrt(sizeSquared);
    return new _Vector3(v.x * scaleFactor, v.y * scaleFactor, v.z * scaleFactor);
  }
  static angleBetween(v1, v2) {
    return v1.angleBetween(v2);
  }
  static distanceBetween(v1, v2) {
    return v1.distanceTo(v2);
  }
  constructor(x = 0, y = 0, z = 0) {
    this.x = x;
    this.y = y;
    this.z = z;
  }
  set(x, y, z) {
    this.x = x;
    this.y = y;
    this.z = z;
  }
  copy(v) {
    this.x = v.x;
    this.y = v.y;
    this.z = v.z;
  }
  clone() {
    return new _Vector3(this.x, this.y, this.z);
  }
  equals(v) {
    return this.x == v.x && this.y == v.y && this.z == v.z;
  }
  add(v) {
    this.x += v.x;
    this.y += v.y;
    this.z += v.z;
  }
  subtract(v) {
    this.x -= v.x;
    this.y -= v.y;
    this.z -= v.z;
  }
  multiply(v) {
    this.x *= v.x;
    this.y *= v.y;
    this.z *= v.z;
  }
  divide(v) {
    this.x /= v.x;
    this.y /= v.y;
    this.z /= v.z;
  }
  dot(v) {
    return this.x * v.x + this.y * v.y + this.z * v.z;
  }
  cross(v) {
    return new _Vector3(
      this.y * v.z - this.z * v.y,
      this.z * v.x - this.x * v.z,
      this.x * v.y - this.y * v.x
    );
  }
  multiplyScalar(n) {
    this.x *= n;
    this.y *= n;
    this.z *= n;
  }
  divideScalar(n) {
    this.x /= n;
    this.y /= n;
    this.z /= n;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  normalize() {
    const sizeSquared = this.x * this.x + this.y * this.y + this.z * this.z;
    if (sizeSquared < 1e-8)
      return;
    const scaleFactor = 1 / Math.sqrt(sizeSquared);
    this.x *= scaleFactor;
    this.y *= scaleFactor;
    this.z *= scaleFactor;
  }
  invert() {
    this.x = -this.x;
    this.y = -this.y;
    this.z = -this.z;
  }
  applyMatrix(m) {
    const v = this.clone();
    const w = 1 / (m.mat[3] * v.x + m.mat[7] * v.y + m.mat[11] * v.z + m.mat[15]);
    this.x = w * (m.mat[0] * v.x + m.mat[4] * v.y + m.mat[8] * v.z + m.mat[12]);
    this.y = w * (m.mat[1] * v.x + m.mat[5] * v.y + m.mat[9] * v.z + m.mat[13]);
    this.z = w * (m.mat[2] * v.x + m.mat[6] * v.y + m.mat[10] * v.z + m.mat[14]);
  }
  applyMatrixAsNormal(m) {
    const v = this.clone();
    const w = 1 / (m.mat[3] * v.x + m.mat[7] * v.y + m.mat[11] * v.z);
    this.x = w * (m.mat[0] * v.x + m.mat[4] * v.y + m.mat[8] * v.z);
    this.y = w * (m.mat[1] * v.x + m.mat[5] * v.y + m.mat[9] * v.z);
    this.z = w * (m.mat[2] * v.x + m.mat[6] * v.y + m.mat[10] * v.z);
  }
  rotate(q) {
    this.copy(q.rotate(this));
  }
  angleBetween(v) {
    const v1Norm = _Vector3.normalize(this);
    const v2Norm = _Vector3.normalize(v);
    return Math.acos(v1Norm.dot(v2Norm));
  }
  distanceTo(v) {
    return Math.sqrt(
      (this.x - v.x) * (this.x - v.x) + (this.y - v.y) * (this.y - v.y) + (this.z - v.z) * (this.z - v.z)
    );
  }
  setPositionFromMatrix(m) {
    this.x = m.mat[12];
    this.y = m.mat[13];
    this.z = m.mat[14];
  }
  setScaleFromMatrix(m) {
    this.x = Math.sqrt(m.mat[0] * m.mat[0] + m.mat[1] * m.mat[1] + m.mat[2] * m.mat[2]);
    this.y = Math.sqrt(m.mat[4] * m.mat[4] + m.mat[5] * m.mat[5] + m.mat[6] * m.mat[6]);
    this.z = Math.sqrt(m.mat[8] * m.mat[8] + m.mat[9] * m.mat[9] + m.mat[10] * m.mat[10]);
  }
};
var Vector3 = _Vector3;
Vector3.ZERO = new _Vector3(0, 0, 0);
Vector3.ONE = new _Vector3(1, 1, 1);
Vector3.UP = new _Vector3(0, 1, 0);
Vector3.DOWN = new _Vector3(0, -1, 0);
Vector3.LEFT = new _Vector3(-1, 0, 0);
Vector3.RIGHT = new _Vector3(1, 0, 0);
Vector3.FORWARD = new _Vector3(0, 0, -1);
Vector3.BACK = new _Vector3(0, 0, 1);
Vector3.X_AXIS = _Vector3.RIGHT;
Vector3.Y_AXIS = _Vector3.UP;
Vector3.Z_AXIS = _Vector3.FORWARD;

// node_modules/gophergfx/src/math/Quaternion.ts
var _Quaternion = class {
  static multiply(q1, q2) {
    const dest = new _Quaternion();
    dest.w = q1.w * q2.w - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z;
    dest.x = q1.w * q2.x + q1.x * q2.w + q1.y * q2.z - q1.z * q2.y;
    dest.y = q1.w * q2.y + q1.y * q2.w + q1.z * q2.x - q1.x * q2.z;
    dest.z = q1.w * q2.z + q1.z * q2.w + q1.x * q2.y - q1.y * q2.x;
    return dest;
  }
  static normalize(q) {
    const dest = q.clone();
    dest.normalize();
    return dest;
  }
  static inverse(q) {
    const dest = q.clone();
    dest.invert();
    return dest;
  }
  static makeRotationX(angle) {
    const dest = new _Quaternion();
    dest.setRotationX(angle);
    return dest;
  }
  static makeRotationY(angle) {
    const dest = new _Quaternion();
    dest.setRotationY(angle);
    return dest;
  }
  static makeRotationZ(angle) {
    const dest = new _Quaternion();
    dest.setRotationZ(angle);
    return dest;
  }
  static makeAxisAngle(axis, angle) {
    const dest = new _Quaternion();
    dest.setAxisAngle(axis, angle);
    return dest;
  }
  static makeEulerAngles(yaw, pitch, roll) {
    const dest = new _Quaternion();
    dest.setEulerAngles(yaw, pitch, roll);
    return dest;
  }
  static makeMatrix(matrix) {
    const dest = new _Quaternion();
    dest.setMatrix(matrix);
    return dest;
  }
  constructor(x = 0, y = 0, z = 0, w = 1) {
    this.x = x;
    this.y = y;
    this.z = z;
    this.w = w;
  }
  set(x, y, z, w) {
    this.x = x;
    this.y = y;
    this.z = z;
    this.w = w;
  }
  setRotationX(angle) {
    this.w = Math.cos(angle / 2);
    this.x = Math.sin(angle / 2);
    this.y = 0;
    this.z = 0;
  }
  setRotationY(angle) {
    this.w = Math.cos(angle / 2);
    this.x = 0;
    this.y = Math.sin(angle / 2);
    this.z = 0;
  }
  setRotationZ(angle) {
    this.w = Math.cos(angle / 2);
    this.x = 0;
    this.y = 0;
    this.z = Math.sin(angle / 2);
  }
  setAxisAngle(axis, angle) {
    const sinAngle = Math.sin(angle / 2);
    this.w = Math.cos(angle / 2);
    this.x = sinAngle * axis.x;
    this.y = sinAngle * axis.y;
    this.z = sinAngle * axis.z;
  }
  setEulerAngles(yaw, pitch, roll) {
    const cosPitch = Math.cos(pitch / 2);
    const sinPitch = Math.sin(pitch / 2);
    const cosYaw = Math.cos(yaw / 2);
    const sinYaw = Math.sin(yaw / 2);
    const cosRoll = Math.cos(-roll / 2);
    const sinRoll = Math.sin(-roll / 2);
    this.x = sinPitch * cosYaw * cosRoll + cosPitch * sinYaw * sinRoll;
    this.y = cosPitch * sinYaw * cosRoll - sinPitch * cosYaw * sinRoll;
    this.z = cosPitch * cosYaw * sinRoll + sinPitch * sinYaw * cosRoll;
    this.w = cosPitch * cosYaw * cosRoll - sinPitch * sinYaw * sinRoll;
  }
  setMatrix(matrix) {
    this.w = Math.sqrt(1 + matrix.mat[0] + matrix.mat[5] + matrix.mat[10]) / 2;
    this.x = (matrix.mat[6] - matrix.mat[9]) / (4 * this.w);
    this.y = (matrix.mat[8] - matrix.mat[2]) / (4 * this.w);
    this.z = (matrix.mat[1] - matrix.mat[4]) / (4 * this.w);
  }
  copy(q) {
    this.x = q.x;
    this.y = q.y;
    this.z = q.z;
    this.w = q.w;
  }
  clone() {
    return new _Quaternion(this.x, this.y, this.z, this.w);
  }
  multiply(q) {
    this.copy(_Quaternion.multiply(q, this));
  }
  normalize() {
    const normalizeFactor = 1 / Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
    this.x *= normalizeFactor;
    this.y *= normalizeFactor;
    this.z *= normalizeFactor;
    this.w *= normalizeFactor;
  }
  rotate(v) {
    const u = new Vector3(this.x, this.y, this.z);
    const result = Vector3.multiplyScalar(u, 2 * u.dot(v));
    result.add(Vector3.multiplyScalar(v, this.w * this.w - u.dot(u)));
    const crossUV = u.cross(v);
    crossUV.multiplyScalar(2 * this.w);
    result.add(crossUV);
    return result;
  }
  invert() {
    const norm = 1 / (this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
    this.x *= -norm;
    this.y *= -norm;
    this.z *= -norm;
    this.w *= norm;
  }
  inverse() {
    return _Quaternion.inverse(this);
  }
  getMatrix() {
    const sqw = this.w * this.w;
    const sqx = this.x * this.x;
    const sqy = this.y * this.y;
    const sqz = this.z * this.z;
    const invs = 1 / (sqx + sqy + sqz + sqw);
    const tmp1 = this.x * this.y;
    const tmp2 = this.z * this.w;
    const tmp3 = this.x * this.z;
    const tmp4 = this.y * this.w;
    const tmp5 = this.y * this.z;
    const tmp6 = this.x * this.w;
    return Matrix4.fromRowMajor(
      (sqx - sqy - sqz + sqw) * invs,
      2 * (tmp1 - tmp2) * invs,
      2 * (tmp3 + tmp4) * invs,
      0,
      2 * (tmp1 + tmp2) * invs,
      (-sqx + sqy - sqz + sqw) * invs,
      2 * (tmp5 - tmp6) * invs,
      0,
      2 * (tmp3 - tmp4) * invs,
      2 * (tmp5 + tmp6) * invs,
      -sqx - sqy + sqz + sqw,
      0,
      0,
      0,
      0,
      1
    );
  }
};
var Quaternion = _Quaternion;
Quaternion.IDENTITY = new _Quaternion();

// node_modules/gophergfx/src/math/Matrix4.ts
var _Matrix4 = class {
  static multiply(m1, m2) {
    const m = new _Matrix4();
    m.mat[0] = 0;
    m.mat[5] = 0;
    m.mat[10] = 0;
    m.mat[15] = 0;
    for (let r = 0; r < 4; r++) {
      for (let c = 0; c < 4; c++) {
        for (let i = 0; i < 4; i++) {
          m.mat[r * 4 + c] += m1.mat[r * 4 + i] * m2.mat[i * 4 + c];
        }
      }
    }
    return m;
  }
  static copy(m) {
    const mat = new _Matrix4();
    mat.copy(m);
    return mat;
  }
  static fromRowMajor(n1, n2, n3, n4, n5, n6, n7, n8, n9, n10, n11, n12, n13, n14, n15, n16) {
    const matrix = new _Matrix4();
    matrix.setRowMajor(n1, n2, n3, n4, n5, n6, n7, n8, n9, n10, n11, n12, n13, n14, n15, n16);
    return matrix;
  }
  static fromColumnMajor(n1, n2, n3, n4, n5, n6, n7, n8, n9, n10, n11, n12, n13, n14, n15, n16) {
    const matrix = new _Matrix4();
    matrix.setColumnMajor(n1, n2, n3, n4, n5, n6, n7, n8, n9, n10, n11, n12, n13, n14, n15, n16);
    return matrix;
  }
  static makeTranslation(v) {
    return _Matrix4.fromRowMajor(
      1,
      0,
      0,
      v.x,
      0,
      1,
      0,
      v.y,
      0,
      0,
      1,
      v.z,
      0,
      0,
      0,
      1
    );
  }
  static makeRotationX(angle) {
    const matrix = new _Matrix4();
    matrix.makeRotationX(angle);
    return matrix;
  }
  static makeRotationY(angle) {
    const matrix = new _Matrix4();
    matrix.makeRotationY(angle);
    return matrix;
  }
  static makeRotationZ(angle) {
    const matrix = new _Matrix4();
    matrix.makeRotationZ(angle);
    return matrix;
  }
  static makeRotation(axis, angle) {
    const matrix = new _Matrix4();
    matrix.makeRotation(axis, angle);
    return matrix;
  }
  static makeScale(scale) {
    const matrix = new _Matrix4();
    matrix.makeScale(scale);
    return matrix;
  }
  static makeTransform(position = Vector3.ZERO, rotation = Quaternion.IDENTITY, scale = Vector3.UP) {
    const matrix = new _Matrix4();
    matrix.makeTransform(position, rotation, scale);
    return matrix;
  }
  static lookAt(eye, target, up) {
    const matrix = new _Matrix4();
    matrix.lookAt(eye, target, up);
    return matrix;
  }
  static makeOrthographic(left, right, bottom, top, near, far) {
    const matrix = new _Matrix4();
    matrix.makeOrthographic(left, right, bottom, top, near, far);
    return matrix;
  }
  static makePerspective(fov, aspectRatio, near, far) {
    const matrix = new _Matrix4();
    matrix.makePerspective(fov, aspectRatio, near, far);
    return matrix;
  }
  static makeFrustum(left, right, bottom, top, near, far) {
    const matrix = new _Matrix4();
    matrix.makeFrustum(left, right, bottom, top, near, far);
    return matrix;
  }
  constructor() {
    this.mat = [
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ];
  }
  setColumnMajor(n1, n2, n3, n4, n5, n6, n7, n8, n9, n10, n11, n12, n13, n14, n15, n16) {
    this.mat[0] = n1;
    this.mat[1] = n2;
    this.mat[2] = n3;
    this.mat[3] = n4;
    this.mat[4] = n5;
    this.mat[5] = n6;
    this.mat[6] = n7;
    this.mat[7] = n8;
    this.mat[8] = n9;
    this.mat[9] = n10;
    this.mat[10] = n11;
    this.mat[11] = n12;
    this.mat[12] = n13;
    this.mat[13] = n14;
    this.mat[14] = n15;
    this.mat[15] = n16;
  }
  setRowMajor(n1, n2, n3, n4, n5, n6, n7, n8, n9, n10, n11, n12, n13, n14, n15, n16) {
    this.mat[0] = n1;
    this.mat[1] = n5;
    this.mat[2] = n9;
    this.mat[3] = n13;
    this.mat[4] = n2;
    this.mat[5] = n6;
    this.mat[6] = n10;
    this.mat[7] = n14;
    this.mat[8] = n3;
    this.mat[9] = n7;
    this.mat[10] = n11;
    this.mat[11] = n15;
    this.mat[12] = n4;
    this.mat[13] = n8;
    this.mat[14] = n12;
    this.mat[15] = n16;
  }
  copy(m) {
    for (let i = 0; i < 16; i++)
      this.mat[i] = m.mat[i];
  }
  clone() {
    const matrix = new _Matrix4();
    for (let i = 0; i < 16; i++)
      matrix.mat[i] = this.mat[i];
    return matrix;
  }
  element(row, col) {
    return this.mat[col * 4 + row];
  }
  set(value, row, col) {
    this.mat[col * 4 + row] = value;
  }
  multiply(m) {
    const temp = _Matrix4.multiply(m, this);
    this.copy(temp);
  }
  makeTranslation(v) {
    this.setRowMajor(
      1,
      0,
      0,
      v.x,
      0,
      1,
      0,
      v.y,
      0,
      0,
      1,
      v.z,
      0,
      0,
      0,
      1
    );
  }
  makeRotationX(angle) {
    const cosTheta = Math.cos(angle);
    const sinTheta = Math.sin(angle);
    this.setRowMajor(
      1,
      0,
      0,
      0,
      0,
      cosTheta,
      -sinTheta,
      0,
      0,
      sinTheta,
      cosTheta,
      0,
      0,
      0,
      0,
      1
    );
  }
  makeRotationY(angle) {
    const cosTheta = Math.cos(angle);
    const sinTheta = Math.sin(angle);
    this.setRowMajor(
      cosTheta,
      0,
      sinTheta,
      0,
      0,
      1,
      0,
      0,
      -sinTheta,
      0,
      cosTheta,
      0,
      0,
      0,
      0,
      1
    );
  }
  makeRotationZ(angle) {
    const cosTheta = Math.cos(angle);
    const sinTheta = Math.sin(angle);
    this.setRowMajor(
      cosTheta,
      -sinTheta,
      0,
      0,
      sinTheta,
      cosTheta,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    );
  }
  makeRotation(axis, angle) {
    const c = Math.cos(angle);
    const s = Math.sin(angle);
    const t = 1 - c;
    const x = axis.x, y = axis.y, z = axis.z;
    const tx = t * x, ty = t * y;
    this.setRowMajor(
      tx * x + c,
      tx * y - s * z,
      tx * z + s * y,
      0,
      tx * y + s * z,
      ty * y + c,
      ty * z - s * x,
      0,
      tx * z - s * y,
      ty * z + s * x,
      t * z * z + c,
      0,
      0,
      0,
      0,
      1
    );
  }
  makeScale(scale) {
    this.setRowMajor(
      scale.x,
      0,
      0,
      0,
      0,
      scale.y,
      0,
      0,
      0,
      0,
      scale.z,
      0,
      0,
      0,
      0,
      1
    );
  }
  getTranslation() {
    return new Vector3(this.mat[12], this.mat[13], this.mat[14]);
  }
  getRotation() {
    return Quaternion.makeMatrix(this);
  }
  getScale() {
    return new Vector3(
      Math.sqrt(this.mat[0] * this.mat[0] + this.mat[1] * this.mat[1] + this.mat[2] * this.mat[2]),
      Math.sqrt(this.mat[4] * this.mat[4] + this.mat[5] * this.mat[5] + this.mat[6] * this.mat[6]),
      Math.sqrt(this.mat[8] * this.mat[8] + this.mat[9] * this.mat[9] + this.mat[10] * this.mat[10])
    );
  }
  makeOrthographic(left, right, bottom, top, near, far) {
    this.setRowMajor(
      2 / (right - left),
      0,
      0,
      -(right + left) / (right - left),
      0,
      2 / (top - bottom),
      0,
      -(top + bottom) / (top - bottom),
      0,
      0,
      -2 / (far - near),
      -(far + near) / (far - near),
      0,
      0,
      0,
      1
    );
  }
  makePerspective(fov, aspectRatio, near, far) {
    const yMax = near * Math.tan(fov * Math.PI / 360);
    const xMax = yMax * aspectRatio;
    this.makeFrustum(-xMax, xMax, -yMax, yMax, near, far);
  }
  makeFrustum(left, right, bottom, top, near, far) {
    this.setRowMajor(
      2 * near / (right - left),
      0,
      (right + left) / (right - left),
      0,
      0,
      2 * near / (top - bottom),
      (top + bottom) / (top - bottom),
      0,
      0,
      0,
      -(far + near) / (far - near),
      -2 * far * near / (far - near),
      0,
      0,
      -1,
      0
    );
  }
  makeTransform(position = Vector3.ZERO, rotation = Quaternion.IDENTITY, scale = Vector3.ONE) {
    this.makeTranslation(position);
    this.multiply(rotation.getMatrix());
    this.multiply(_Matrix4.makeScale(scale));
  }
  lookAt(eye, target, up = Vector3.UP) {
    const z = Vector3.subtract(eye, target);
    z.normalize();
    const x = Vector3.cross(up, z);
    x.normalize();
    const y = Vector3.cross(z, x);
    const rotation = _Matrix4.fromRowMajor(
      x.x,
      y.x,
      z.x,
      0,
      x.y,
      y.y,
      z.y,
      0,
      x.z,
      y.z,
      z.z,
      0,
      0,
      0,
      0,
      1
    );
    const translation = _Matrix4.makeTranslation(eye);
    this.copy(_Matrix4.multiply(rotation, translation));
  }
  multiplyScalar(x) {
    for (let i = 0; i < 16; i++)
      this.mat[i] *= x;
  }
  determinant() {
    const determinant = this.mat[3] * this.mat[6] * this.mat[9] * this.mat[12] - this.mat[2] * this.mat[7] * this.mat[9] * this.mat[12] - this.mat[3] * this.mat[5] * this.mat[10] * this.mat[12] + this.mat[1] * this.mat[7] * this.mat[10] * this.mat[12] + this.mat[2] * this.mat[5] * this.mat[11] * this.mat[12] - this.mat[1] * this.mat[6] * this.mat[11] * this.mat[12] - this.mat[3] * this.mat[6] * this.mat[8] * this.mat[13] + this.mat[2] * this.mat[7] * this.mat[8] * this.mat[13] + this.mat[3] * this.mat[4] * this.mat[10] * this.mat[13] - this.mat[0] * this.mat[7] * this.mat[10] * this.mat[13] - this.mat[2] * this.mat[4] * this.mat[11] * this.mat[13] + this.mat[0] * this.mat[6] * this.mat[11] * this.mat[13] + this.mat[3] * this.mat[5] * this.mat[8] * this.mat[14] - this.mat[1] * this.mat[7] * this.mat[8] * this.mat[14] - this.mat[3] * this.mat[4] * this.mat[9] * this.mat[14] + this.mat[0] * this.mat[7] * this.mat[9] * this.mat[14] + this.mat[1] * this.mat[4] * this.mat[11] * this.mat[14] - this.mat[0] * this.mat[5] * this.mat[11] * this.mat[14] - this.mat[2] * this.mat[5] * this.mat[8] * this.mat[15] + this.mat[1] * this.mat[6] * this.mat[8] * this.mat[15] + this.mat[2] * this.mat[4] * this.mat[9] * this.mat[15] - this.mat[0] * this.mat[6] * this.mat[9] * this.mat[15] - this.mat[1] * this.mat[4] * this.mat[10] * this.mat[15] + this.mat[0] * this.mat[5] * this.mat[10] * this.mat[15];
    return determinant;
  }
  inverse() {
    const determinant = this.determinant();
    if (Math.abs(determinant) < 1e-8)
      return new _Matrix4();
    const inverse = new _Matrix4();
    inverse.mat[0] = (this.mat[6] * this.mat[11] * this.mat[13] - this.mat[7] * this.mat[10] * this.mat[13] + this.mat[7] * this.mat[9] * this.mat[14] - this.mat[5] * this.mat[11] * this.mat[14] - this.mat[6] * this.mat[9] * this.mat[15] + this.mat[5] * this.mat[10] * this.mat[15]) / determinant;
    inverse.mat[1] = (this.mat[3] * this.mat[10] * this.mat[13] - this.mat[2] * this.mat[11] * this.mat[13] - this.mat[3] * this.mat[9] * this.mat[14] + this.mat[1] * this.mat[11] * this.mat[14] + this.mat[2] * this.mat[9] * this.mat[15] - this.mat[1] * this.mat[10] * this.mat[15]) / determinant;
    inverse.mat[2] = (this.mat[2] * this.mat[7] * this.mat[13] - this.mat[3] * this.mat[6] * this.mat[13] + this.mat[3] * this.mat[5] * this.mat[14] - this.mat[1] * this.mat[7] * this.mat[14] - this.mat[2] * this.mat[5] * this.mat[15] + this.mat[1] * this.mat[6] * this.mat[15]) / determinant;
    inverse.mat[3] = (this.mat[3] * this.mat[6] * this.mat[9] - this.mat[2] * this.mat[7] * this.mat[9] - this.mat[3] * this.mat[5] * this.mat[10] + this.mat[1] * this.mat[7] * this.mat[10] + this.mat[2] * this.mat[5] * this.mat[11] - this.mat[1] * this.mat[6] * this.mat[11]) / determinant;
    inverse.mat[4] = (this.mat[7] * this.mat[10] * this.mat[12] - this.mat[6] * this.mat[11] * this.mat[12] - this.mat[7] * this.mat[8] * this.mat[14] + this.mat[4] * this.mat[11] * this.mat[14] + this.mat[6] * this.mat[8] * this.mat[15] - this.mat[4] * this.mat[10] * this.mat[15]) / determinant;
    inverse.mat[5] = (this.mat[2] * this.mat[11] * this.mat[12] - this.mat[3] * this.mat[10] * this.mat[12] + this.mat[3] * this.mat[8] * this.mat[14] - this.mat[0] * this.mat[11] * this.mat[14] - this.mat[2] * this.mat[8] * this.mat[15] + this.mat[0] * this.mat[10] * this.mat[15]) / determinant;
    inverse.mat[6] = (this.mat[3] * this.mat[6] * this.mat[12] - this.mat[2] * this.mat[7] * this.mat[12] - this.mat[3] * this.mat[4] * this.mat[14] + this.mat[0] * this.mat[7] * this.mat[14] + this.mat[2] * this.mat[4] * this.mat[15] - this.mat[0] * this.mat[6] * this.mat[15]) / determinant;
    inverse.mat[7] = (this.mat[2] * this.mat[7] * this.mat[8] - this.mat[3] * this.mat[6] * this.mat[8] + this.mat[3] * this.mat[4] * this.mat[10] - this.mat[0] * this.mat[7] * this.mat[10] - this.mat[2] * this.mat[4] * this.mat[11] + this.mat[0] * this.mat[6] * this.mat[11]) / determinant;
    inverse.mat[8] = (this.mat[5] * this.mat[11] * this.mat[12] - this.mat[7] * this.mat[9] * this.mat[12] + this.mat[7] * this.mat[8] * this.mat[13] - this.mat[4] * this.mat[11] * this.mat[13] - this.mat[5] * this.mat[8] * this.mat[15] + this.mat[4] * this.mat[9] * this.mat[15]) / determinant;
    inverse.mat[9] = (this.mat[3] * this.mat[9] * this.mat[12] - this.mat[1] * this.mat[11] * this.mat[12] - this.mat[3] * this.mat[8] * this.mat[13] + this.mat[0] * this.mat[11] * this.mat[13] + this.mat[1] * this.mat[8] * this.mat[15] - this.mat[0] * this.mat[9] * this.mat[15]) / determinant;
    inverse.mat[10] = (this.mat[1] * this.mat[7] * this.mat[12] - this.mat[3] * this.mat[5] * this.mat[12] + this.mat[3] * this.mat[4] * this.mat[13] - this.mat[0] * this.mat[7] * this.mat[13] - this.mat[1] * this.mat[4] * this.mat[15] + this.mat[0] * this.mat[5] * this.mat[15]) / determinant;
    inverse.mat[11] = (this.mat[3] * this.mat[5] * this.mat[8] - this.mat[1] * this.mat[7] * this.mat[8] - this.mat[3] * this.mat[4] * this.mat[9] + this.mat[0] * this.mat[7] * this.mat[9] + this.mat[1] * this.mat[4] * this.mat[11] - this.mat[0] * this.mat[5] * this.mat[11]) / determinant;
    inverse.mat[12] = (this.mat[6] * this.mat[9] * this.mat[12] - this.mat[5] * this.mat[10] * this.mat[12] - this.mat[6] * this.mat[8] * this.mat[13] + this.mat[4] * this.mat[10] * this.mat[13] + this.mat[5] * this.mat[8] * this.mat[14] - this.mat[4] * this.mat[9] * this.mat[14]) / determinant;
    inverse.mat[13] = (this.mat[1] * this.mat[10] * this.mat[12] - this.mat[2] * this.mat[9] * this.mat[12] + this.mat[2] * this.mat[8] * this.mat[13] - this.mat[0] * this.mat[10] * this.mat[13] - this.mat[1] * this.mat[8] * this.mat[14] + this.mat[0] * this.mat[9] * this.mat[14]) / determinant;
    inverse.mat[14] = (this.mat[2] * this.mat[5] * this.mat[12] - this.mat[1] * this.mat[6] * this.mat[12] - this.mat[2] * this.mat[4] * this.mat[13] + this.mat[0] * this.mat[6] * this.mat[13] + this.mat[1] * this.mat[4] * this.mat[14] - this.mat[0] * this.mat[5] * this.mat[14]) / determinant;
    inverse.mat[15] = (this.mat[1] * this.mat[6] * this.mat[8] - this.mat[2] * this.mat[5] * this.mat[8] + this.mat[2] * this.mat[4] * this.mat[9] - this.mat[0] * this.mat[6] * this.mat[9] - this.mat[1] * this.mat[4] * this.mat[10] + this.mat[0] * this.mat[5] * this.mat[10]) / determinant;
    return inverse;
  }
  invert() {
    const inverseMatrix = this.inverse();
    this.copy(inverseMatrix);
  }
  transpose() {
    return _Matrix4.fromRowMajor(
      this.mat[0],
      this.mat[1],
      this.mat[2],
      this.mat[3],
      this.mat[4],
      this.mat[5],
      this.mat[6],
      this.mat[7],
      this.mat[8],
      this.mat[9],
      this.mat[10],
      this.mat[11],
      this.mat[12],
      this.mat[13],
      this.mat[14],
      this.mat[15]
    );
  }
  decompose(position, rotation, scale) {
    position.setPositionFromMatrix(this);
    scale.setScaleFromMatrix(this);
    const rotationMatrix = new _Matrix4();
    rotationMatrix.mat[0] = this.mat[0] / scale.x;
    rotationMatrix.mat[1] = this.mat[1] / scale.x;
    rotationMatrix.mat[2] = this.mat[2] / scale.x;
    rotationMatrix.mat[3] = 0;
    rotationMatrix.mat[4] = this.mat[4] / scale.y;
    rotationMatrix.mat[5] = this.mat[5] / scale.y;
    rotationMatrix.mat[6] = this.mat[6] / scale.y;
    rotationMatrix.mat[7] = 0;
    rotationMatrix.mat[8] = this.mat[8] / scale.z;
    rotationMatrix.mat[9] = this.mat[9] / scale.z;
    rotationMatrix.mat[10] = this.mat[10] / scale.z;
    rotationMatrix.mat[11] = 0;
    rotationMatrix.mat[12] = 0;
    rotationMatrix.mat[13] = 0;
    rotationMatrix.mat[14] = 0;
    rotationMatrix.mat[15] = 1;
    rotation.setMatrix(rotationMatrix);
  }
};
var Matrix4 = _Matrix4;
Matrix4.IDENTITY = new _Matrix4();

// node_modules/gophergfx/src/core/Transform3.ts
var Transform3 = class {
  constructor() {
    this.children = [];
    this.position = new Vector3();
    this.rotation = new Quaternion();
    this.scale = new Vector3(1, 1, 1);
    this.visible = true;
    this.autoUpdateMatrix = true;
    this.matrix = new Matrix4();
    this.worldMatrix = new Matrix4();
    this.worldPosition = new Vector3();
    this.worldRotation = new Quaternion();
    this.worldScale = new Vector3();
    this.parent = null;
  }
  draw(parent, camera, lightManager) {
    if (!this.visible)
      return;
    this.children.forEach((elem) => {
      elem.draw(this, camera, lightManager);
    });
  }
  computeWorldTransform() {
    if (this.autoUpdateMatrix) {
      this.matrix.makeTransform(this.position, this.rotation, this.scale);
    }
    if (this.parent) {
      this.worldMatrix.copy(this.parent.worldMatrix);
      this.worldMatrix.multiply(this.matrix);
    } else {
      this.worldMatrix.copy(this.matrix);
    }
    this.worldMatrix.decompose(this.worldPosition, this.worldRotation, this.worldScale);
    this.children.forEach((elem) => {
      elem.computeWorldTransform();
    });
  }
  add(child) {
    this.children.push(child);
    child.parent = this;
  }
  remove() {
    if (this.parent == null)
      return false;
    else
      return this.parent.removeChild(this) != null;
  }
  removeChild(child) {
    const index = this.children.indexOf(child);
    if (index == -1) {
      return null;
    } else {
      const removedElement = this.children.splice(index, 1);
      removedElement[0].parent = null;
      return removedElement[0];
    }
  }
  setLights(lightManager) {
    this.children.forEach((elem) => {
      elem.setLights(lightManager);
    });
  }
  translate(translation) {
    this.position.add(this.rotation.rotate(translation));
  }
  translateX(distance) {
    this.position.add(this.rotation.rotate(new Vector3(distance, 0, 0)));
  }
  translateY(distance) {
    this.position.add(this.rotation.rotate(new Vector3(0, distance, 0)));
  }
  translateZ(distance) {
    this.position.add(this.rotation.rotate(new Vector3(0, 0, distance)));
  }
  lookAt(target, up = Vector3.UP) {
    const rotationMatrix = Matrix4.lookAt(this.position, target, up);
    this.rotation.setMatrix(rotationMatrix);
  }
};

// node_modules/gophergfx/src/core/Camera.ts
var Camera = class extends Transform3 {
  constructor() {
    super();
    this.fov = 0;
    this.aspectRatio = 0;
    this.near = 0;
    this.far = 0;
    this.left = 0;
    this.right = 0;
    this.projectionMatrixDirty = true;
    this.projectionMatrix = new Matrix4();
    this.viewMatrix = new Matrix4();
  }
  setPerspectiveCamera(fov, aspectRatio, near, far) {
    this.fov = fov;
    this.aspectRatio = aspectRatio;
    this.near = near;
    this.far = far;
    this.projectionMatrixDirty = true;
    this.projectionMatrix.makePerspective(fov, aspectRatio, near, far);
  }
  setOrthographicCamera(left, right, bottom, top, near, far) {
    this.left = left;
    this.right = right;
    this.aspectRatio = Math.abs((right - left) / (top - bottom));
    this.near = near;
    this.far = far;
    this.projectionMatrixDirty = true;
    this.projectionMatrix.makeOrthographic(left, right, bottom, top, near, far);
  }
  computeWorldTransform() {
    super.computeWorldTransform();
    this.viewMatrix = this.worldMatrix.inverse();
  }
  getAspectRatio() {
    return this.aspectRatio;
  }
  getNear() {
    return this.near;
  }
  getFar() {
    return this.far;
  }
  getLeft() {
    return this.left;
  }
  getRight() {
    return this.right;
  }
};

// node_modules/gophergfx/src/math/Matrix3.ts
var _Matrix3 = class {
  static multiply(m1, m2) {
    const m = new _Matrix3();
    m.mat[0] = m1.mat[0] * m2.mat[0] + m1.mat[1] * m2.mat[3] + m1.mat[2] * m2.mat[6];
    m.mat[1] = m1.mat[0] * m2.mat[1] + m1.mat[1] * m2.mat[4] + m1.mat[2] * m2.mat[7];
    m.mat[2] = m1.mat[0] * m2.mat[2] + m1.mat[1] * m2.mat[5] + m1.mat[2] * m2.mat[8];
    m.mat[3] = m1.mat[3] * m2.mat[0] + m1.mat[4] * m2.mat[3] + m1.mat[5] * m2.mat[6];
    m.mat[4] = m1.mat[3] * m2.mat[1] + m1.mat[4] * m2.mat[4] + m1.mat[5] * m2.mat[7];
    m.mat[5] = m1.mat[3] * m2.mat[2] + m1.mat[4] * m2.mat[5] + m1.mat[5] * m2.mat[8];
    m.mat[6] = m1.mat[6] * m2.mat[0] + m1.mat[7] * m2.mat[3] + m1.mat[8] * m2.mat[6];
    m.mat[7] = m1.mat[6] * m2.mat[1] + m1.mat[7] * m2.mat[4] + m1.mat[8] * m2.mat[7];
    m.mat[8] = m1.mat[6] * m2.mat[2] + m1.mat[7] * m2.mat[5] + m1.mat[8] * m2.mat[8];
    return m;
  }
  static copy(m) {
    const mat = new _Matrix3();
    mat.copy(m);
    return mat;
  }
  static fromRowMajor(n1, n2, n3, n4, n5, n6, n7, n8, n9) {
    const matrix = new _Matrix3();
    matrix.setRowMajor(n1, n2, n3, n4, n5, n6, n7, n8, n9);
    return matrix;
  }
  static fromColumnMajor(n1, n2, n3, n4, n5, n6, n7, n8, n9) {
    const matrix = new _Matrix3();
    matrix.setColumnMajor(n1, n2, n3, n4, n5, n6, n7, n8, n9);
    return matrix;
  }
  static makeTranslation(v) {
    return _Matrix3.fromRowMajor(
      1,
      0,
      v.x,
      0,
      1,
      v.y,
      0,
      0,
      1
    );
  }
  static makeRotation(angle) {
    const matrix = new _Matrix3();
    matrix.makeRotation(angle);
    return matrix;
  }
  static makeScale(scale) {
    const matrix = new _Matrix3();
    matrix.makeScale(scale);
    return matrix;
  }
  constructor() {
    this.mat = [
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ];
  }
  setColumnMajor(n1, n2, n3, n4, n5, n6, n7, n8, n9) {
    this.mat[0] = n1;
    this.mat[1] = n2;
    this.mat[2] = n3;
    this.mat[3] = n4;
    this.mat[4] = n5;
    this.mat[5] = n6;
    this.mat[6] = n7;
    this.mat[7] = n8;
    this.mat[8] = n9;
  }
  setRowMajor(n1, n2, n3, n4, n5, n6, n7, n8, n9) {
    this.mat[0] = n1;
    this.mat[1] = n4;
    this.mat[2] = n7;
    this.mat[3] = n2;
    this.mat[4] = n5;
    this.mat[5] = n8;
    this.mat[6] = n3;
    this.mat[7] = n6;
    this.mat[8] = n9;
  }
  copy(m) {
    for (let i = 0; i < 9; i++)
      this.mat[i] = m.mat[i];
  }
  element(row, col) {
    return this.mat[col * 3 + row];
  }
  set(value, row, col) {
    this.mat[col * 3 + row] = value;
  }
  multiply(m) {
    const temp = _Matrix3.multiply(m, this);
    this.copy(temp);
  }
  makeTranslation(v) {
    this.setRowMajor(
      1,
      0,
      v.x,
      0,
      1,
      v.y,
      0,
      0,
      1
    );
  }
  makeRotation(angle) {
    const cosTheta = Math.cos(angle);
    const sinTheta = Math.sin(angle);
    this.setRowMajor(
      cosTheta,
      -sinTheta,
      0,
      sinTheta,
      cosTheta,
      0,
      0,
      0,
      1
    );
  }
  makeScale(scale) {
    this.setRowMajor(
      scale.x,
      0,
      0,
      0,
      scale.y,
      0,
      0,
      0,
      1
    );
  }
  makeTransform(position = Vector2.ZERO, rotation = 0, scale = Vector2.ONE) {
    this.makeTranslation(position);
    this.multiply(_Matrix3.makeRotation(rotation));
    this.multiply(_Matrix3.makeScale(scale));
  }
  multiplyScalar(x) {
    for (let i = 0; i < 9; i++)
      this.mat[i] *= x;
  }
  inverse() {
    const inverse = new _Matrix3();
    const det = this.mat[0] * this.mat[4] * this.mat[8] + this.mat[1] * this.mat[5] * this.mat[6] + this.mat[2] * this.mat[3] * this.mat[7] - this.mat[0] * this.mat[5] * this.mat[7] - this.mat[1] * this.mat[3] * this.mat[8] - this.mat[2] * this.mat[4] * this.mat[6];
    this.mat[0] = (this.mat[4] * this.mat[8] - this.mat[5] * this.mat[7]) / det;
    this.mat[1] = (this.mat[2] * this.mat[7] - this.mat[1] * this.mat[8]) / det;
    this.mat[2] = (this.mat[1] * this.mat[5] - this.mat[2] * this.mat[4]) / det;
    this.mat[3] = (this.mat[5] * this.mat[6] - this.mat[3] * this.mat[8]) / det;
    this.mat[4] = (this.mat[0] * this.mat[8] - this.mat[2] * this.mat[6]) / det;
    this.mat[5] = (this.mat[2] * this.mat[3] - this.mat[0] * this.mat[5]) / det;
    this.mat[6] = (this.mat[3] * this.mat[7] - this.mat[4] * this.mat[6]) / det;
    this.mat[7] = (this.mat[1] * this.mat[6] - this.mat[0] * this.mat[7]) / det;
    this.mat[8] = (this.mat[0] * this.mat[4] - this.mat[1] * this.mat[3]) / det;
    return inverse;
  }
  invert() {
    const inverseMatrix = this.inverse();
    this.copy(inverseMatrix);
  }
  transpose() {
    return _Matrix3.fromRowMajor(
      this.mat[0],
      this.mat[1],
      this.mat[2],
      this.mat[3],
      this.mat[4],
      this.mat[5],
      this.mat[6],
      this.mat[7],
      this.mat[8]
    );
  }
  decompose() {
    const position = new Vector2();
    const scale = new Vector2();
    position.setPositionFromMatrix(this);
    scale.setScaleFromMatrix(this);
    return [position, Math.atan2(this.mat[1], this.mat[3]), scale];
  }
};
var Matrix3 = _Matrix3;
Matrix3.IDENTITY = new _Matrix3();

// node_modules/gophergfx/src/math/BoundingBox2.ts
var BoundingBox2 = class {
  constructor() {
    this.min = new Vector2();
    this.max = new Vector2();
  }
  copy(box) {
    this.min.copy(box.min);
    this.max.copy(box.max);
  }
  transform(translation, rotation, scale) {
    this.min.multiply(scale);
    this.max.multiply(scale);
    const topLeft = new Vector2(this.min.x, this.max.y);
    const topRight = new Vector2(this.max.x, this.max.y);
    const bottomLeft = new Vector2(this.min.x, this.min.y);
    const bottomRight = new Vector2(this.max.x, this.min.y);
    topLeft.rotate(rotation);
    topRight.rotate(rotation);
    bottomLeft.rotate(rotation);
    bottomRight.rotate(rotation);
    this.min.x = Math.min(topLeft.x, Math.min(topRight.x, Math.min(bottomLeft.x, bottomRight.x)));
    this.min.y = Math.min(topLeft.y, Math.min(topRight.y, Math.min(bottomLeft.y, bottomRight.y)));
    this.max.x = Math.max(topLeft.x, Math.max(topRight.x, Math.max(bottomLeft.x, bottomRight.x)));
    this.max.y = Math.max(topLeft.y, Math.max(topRight.y, Math.max(bottomLeft.y, bottomRight.y)));
    this.min.add(translation);
    this.max.add(translation);
  }
  intersects(box) {
    const thisCenter = Vector2.add(this.max, this.min);
    thisCenter.multiplyScalar(0.5);
    const otherCenter = Vector2.add(box.max, box.min);
    otherCenter.multiplyScalar(0.5);
    const thisHalfWidth = Vector2.subtract(this.max, this.min);
    thisHalfWidth.multiplyScalar(0.5);
    const otherHalfWidth = Vector2.subtract(box.max, box.min);
    otherHalfWidth.multiplyScalar(0.5);
    if (Math.abs(thisCenter.x - otherCenter.x) > thisHalfWidth.x + otherHalfWidth.x)
      return false;
    else if (Math.abs(thisCenter.y - otherCenter.y) > thisHalfWidth.y + otherHalfWidth.y)
      return false;
    else
      return true;
  }
};

// node_modules/gophergfx/src/math/BoundingCircle.ts
var BoundingCircle = class {
  constructor() {
    this.center = new Vector2();
    this.radius = 0;
  }
  copy(circle) {
    this.center.copy(circle.center);
    this.radius = circle.radius;
  }
  transform(translation, scale) {
    this.center.multiply(scale);
    this.center.add(translation);
    if (scale.x >= scale.y)
      this.radius *= scale.x;
    else
      this.radius *= scale.y;
  }
  intersects(circle) {
    const distance = this.center.distanceTo(circle.center);
    if (distance < this.radius + circle.radius)
      return true;
    else
      return false;
  }
};

// node_modules/gophergfx/src/core/Transform2.ts
var IntersectionMode2 = /* @__PURE__ */ ((IntersectionMode22) => {
  IntersectionMode22[IntersectionMode22["BOUNDING_CIRCLE"] = 0] = "BOUNDING_CIRCLE";
  IntersectionMode22[IntersectionMode22["AXIS_ALIGNED_BOUNDING_BOX"] = 1] = "AXIS_ALIGNED_BOUNDING_BOX";
  return IntersectionMode22;
})(IntersectionMode2 || {});
var Transform2 = class {
  constructor() {
    this.children = [];
    this.position = new Vector2();
    this.rotation = 0;
    this.scale = new Vector2(1, 1);
    this.matrix = new Matrix3();
    this.worldPosition = new Vector2();
    this.worldRotation = 0;
    this.worldScale = new Vector2(1, 1);
    this.worldMatrix = new Matrix3();
    this.layer = 0;
    this.visible = true;
    this.parent = null;
    this.boundingBox = new BoundingBox2();
    this.boundingCircle = new BoundingCircle();
  }
  draw(parent) {
    if (!this.visible)
      return;
    this.children.forEach((elem) => {
      elem.draw(this);
    });
  }
  computeWorldTransform() {
    this.matrix.makeTransform(this.position, this.rotation, this.scale);
    if (this.parent) {
      this.worldMatrix.copy(this.parent.worldMatrix);
      this.worldMatrix.multiply(this.matrix);
    } else {
      this.worldMatrix.copy(this.matrix);
    }
    [this.worldPosition, this.worldRotation, this.worldScale] = this.worldMatrix.decompose();
    this.children.forEach((elem) => {
      elem.computeWorldTransform();
    });
  }
  add(child) {
    this.children.push(child);
    child.parent = this;
  }
  remove() {
    if (this.parent == null)
      return false;
    else
      return this.parent.removeChild(this) != null;
  }
  removeChild(child) {
    const index = this.children.indexOf(child);
    if (index == -1) {
      return null;
    } else {
      const removedElement = this.children.splice(index, 1);
      removedElement[0].parent = null;
      return removedElement[0];
    }
  }
  translate(translation) {
    const localVector = Vector2.rotate(translation, this.rotation);
    this.position.add(localVector);
  }
  translateX(distance) {
    const localVector = Vector2.rotate(new Vector2(distance, 0), this.rotation);
    this.position.add(localVector);
  }
  translateY(distance) {
    const localVector = Vector2.rotate(new Vector2(0, distance), this.rotation);
    this.position.add(localVector);
  }
  lookAt(target, lookVector = Vector2.UP) {
    const targetVector = Vector2.subtract(target, this.position);
    if (targetVector.length() > 0) {
      this.rotation = lookVector.angleBetweenSigned(targetVector);
    }
  }
  intersects(other, mode = 0 /* BOUNDING_CIRCLE */) {
    if (mode == 0 /* BOUNDING_CIRCLE */) {
      const thisCircle = new BoundingCircle();
      thisCircle.copy(this.boundingCircle);
      thisCircle.transform(this.position, this.scale);
      const otherCircle = new BoundingCircle();
      otherCircle.copy(other.boundingCircle);
      otherCircle.transform(other.position, other.scale);
      return thisCircle.intersects(otherCircle);
    } else if (mode == 1 /* AXIS_ALIGNED_BOUNDING_BOX */) {
      const thisBox = new BoundingBox2();
      thisBox.copy(this.boundingBox);
      thisBox.transform(this.position, this.rotation, this.scale);
      const otherBox = new BoundingBox2();
      otherBox.copy(other.boundingBox);
      otherBox.transform(other.position, other.rotation, other.scale);
      return thisBox.intersects(otherBox);
    } else {
      return false;
    }
  }
};

// node_modules/gophergfx/src/lights/LightManager.ts
var LightManager = class {
  constructor() {
    this.lights = [];
    this.lightTypes = [];
    this.lightPositions = [];
    this.ambientIntensities = [];
    this.diffuseIntensities = [];
    this.specularIntensities = [];
  }
  clear() {
    this.lights = [];
    this.lightTypes = [];
    this.lightPositions = [];
    this.ambientIntensities = [];
    this.diffuseIntensities = [];
    this.specularIntensities = [];
  }
  addLight(light) {
    const alreadyAdded = this.lights.some((elem) => {
      return elem == light;
    });
    if (!alreadyAdded)
      this.lights.push(light);
  }
  getNumLights() {
    return this.lights.length;
  }
  updateLights() {
    this.lights.forEach((light) => {
      if (light.visible) {
        this.lightPositions.push(light.worldPosition.x, light.worldPosition.y, light.worldPosition.z);
        this.lightTypes.push(light.getType());
        this.ambientIntensities.push(light.ambientIntensity.r, light.ambientIntensity.g, light.ambientIntensity.b);
        this.diffuseIntensities.push(light.diffuseIntensity.r, light.diffuseIntensity.g, light.diffuseIntensity.b);
        this.specularIntensities.push(light.specularIntensity.r, light.specularIntensity.g, light.specularIntensity.b);
      } else {
        this.lightPositions.push(light.worldPosition.x, light.worldPosition.y, light.worldPosition.z);
        this.lightTypes.push(light.getType());
        this.ambientIntensities.push(0, 0, 0);
        this.diffuseIntensities.push(0, 0, 0);
        this.specularIntensities.push(0, 0, 0);
      }
    });
  }
};

// node_modules/gophergfx/src/core/Scene.ts
var Scene = class {
  constructor() {
    this.root3d = new Transform3();
    this.root2d = new Transform2();
    this.lightManager = new LightManager();
  }
  draw(camera) {
    camera.computeWorldTransform();
    this.computeWorldTransforms();
    this.lightManager.clear();
    this.root3d.setLights(this.lightManager);
    this.lightManager.updateLights();
    this.root3d.children.forEach((elem) => {
      elem.draw(this.root3d, camera, this.lightManager);
    });
    this.root2d.children.forEach((elem) => {
      elem.draw(this.root2d);
    });
  }
  add(child) {
    if (child instanceof Transform3) {
      this.root3d.add(child);
    } else {
      this.root2d.add(child);
    }
  }
  computeWorldTransforms() {
    this.root3d.children.forEach((elem) => {
      elem.computeWorldTransform();
    });
    this.root2d.children.forEach((elem) => {
      elem.computeWorldTransform();
    });
  }
};

// node_modules/gophergfx/src/loaders/AssetManager.ts
var AssetManager = class {
  constructor() {
    this.requestedAssets = [];
    this.loadedAssets = [];
    this.errorAssets = [];
  }
  allAssetsLoaded() {
    return this.requestedAssets.length == this.loadedAssets.length + this.errorAssets.length;
  }
};

// node_modules/gophergfx/src/core/GfxApp.ts
var GfxApp = class {
  static getInstance() {
    return GfxApp.instance;
  }
  constructor() {
    GfxApp.instance = this;
    this.time = Date.now();
    this.paused = false;
    this.camera = new Camera();
    this.scene = new Scene();
    this.renderer = new Renderer();
    this.assetManager = new AssetManager();
    this.runInBackground = false;
    this.waitForAssetLoading = true;
    this.previousTouches = [new Vector2()];
    window.addEventListener("resize", () => {
      this.resize();
    }, false);
    window.addEventListener("mousedown", (event) => {
      this.onMouseDown(event);
    });
    window.addEventListener("mouseup", (event) => {
      this.onMouseUp(event);
    });
    window.addEventListener("mousemove", (event) => {
      this.onMouseMove(event);
    });
    window.addEventListener("wheel", (event) => {
      this.onMouseWheel(event);
    });
    window.addEventListener("keydown", (event) => {
      this.onKeyDown(event);
    });
    window.addEventListener("keyup", (event) => {
      this.onKeyUp(event);
    });
    window.addEventListener("focus", (event) => {
      this.onFocusReceived(event);
    });
    window.addEventListener("blur", (event) => {
      this.onFocusLost(event);
    });
    window.addEventListener("touchstart", (event) => {
      this.onTouchStart(event);
    }, { passive: false });
    window.addEventListener("touchmove", (event) => {
      this.onTouchMove(event);
    }, { passive: false });
    window.addEventListener("touchend", (event) => {
      this.onTouchEnd(event);
    }, { passive: false });
    window.addEventListener("contextmenu", (event) => event.preventDefault());
    this.camera.setOrthographicCamera(0, 1, 0, 1, 0.01, 1);
  }
  start() {
    if (this.waitForAssetLoading && !this.assetManager.allAssetsLoaded()) {
      window.requestAnimationFrame(() => this.start());
    } else {
      this.createScene();
      this.mainLoop();
    }
  }
  mainLoop() {
    if (this.runInBackground || !this.paused) {
      this.update((Date.now() - this.time) / 1e3);
      this.time = Date.now();
    }
    this.renderer.render(this.scene, this.camera);
    window.requestAnimationFrame(() => this.mainLoop());
  }
  resize() {
    this.renderer.resize(window.innerWidth, window.innerHeight, this.camera.getAspectRatio());
  }
  onTouchStart(event) {
    event.preventDefault();
    if (event.touches.length == 1)
      this.simulateMouseEvent("mousedown", event);
  }
  onTouchMove(event) {
    event.preventDefault();
    if (event.touches.length == 1)
      this.simulateMouseEvent("mousemove", event);
    else
      this.simulateWheelEvent(event);
  }
  onTouchEnd(event) {
    event.preventDefault();
    if (event.touches.length == 1)
      this.simulateMouseEvent("mouseup", event);
  }
  onFocusReceived(event) {
    this.resume();
  }
  onFocusLost(event) {
    this.pause();
  }
  pause() {
    this.paused = true;
  }
  resume() {
    this.time = Date.now();
    this.paused = false;
  }
  isPaused() {
    return this.paused;
  }
  getNormalizedDeviceCoordinates(mouseX, mouseY) {
    return this.renderer.getNormalizedDeviceCoordinates(mouseX, mouseY);
  }
  simulateMouseEvent(type, touchEvent) {
    if (this.previousTouches.length == 1) {
      const mouseEvent = new MouseEvent(type, {
        "button": 0,
        "clientX": touchEvent.touches[0].clientX,
        "clientY": touchEvent.touches[0].clientY,
        "screenX": touchEvent.touches[0].screenX,
        "screenY": touchEvent.touches[0].screenY,
        "movementX": touchEvent.touches[0].clientX - this.previousTouches[0].x,
        "movementY": touchEvent.touches[0].clientY - this.previousTouches[0].y,
        "view": touchEvent.view,
        cancelable: true,
        bubbles: true
      });
      touchEvent.target.dispatchEvent(mouseEvent);
    }
    this.previousTouches = [new Vector2(touchEvent.touches[0].clientX, touchEvent.touches[0].clientY)];
  }
  simulateWheelEvent(touchEvent) {
    if (this.previousTouches.length > 1) {
      const previousDistance = this.previousTouches[0].distanceTo(this.previousTouches[1]);
      const currentDistance = Math.sqrt(
        (touchEvent.touches[0].clientX - touchEvent.touches[1].clientX) * (touchEvent.touches[0].clientX - touchEvent.touches[1].clientX) + (touchEvent.touches[0].clientY - touchEvent.touches[1].clientY) * (touchEvent.touches[0].clientY - touchEvent.touches[1].clientY)
      );
      let scaleFactor = 0;
      if (currentDistance > previousDistance)
        scaleFactor = -currentDistance / previousDistance;
      else if (currentDistance < previousDistance)
        scaleFactor = previousDistance / currentDistance;
      const wheelEvent = new WheelEvent("wheel", {
        "clientX": (touchEvent.touches[0].clientX + touchEvent.touches[1].clientX) / 2,
        "clientY": (touchEvent.touches[0].clientY + touchEvent.touches[1].clientY) / 2,
        "screenX": (touchEvent.touches[0].screenX + touchEvent.touches[1].screenX) / 2,
        "screenY": (touchEvent.touches[0].screenY + touchEvent.touches[1].screenY) / 2,
        "movementX": (touchEvent.touches[0].clientX - this.previousTouches[0].x + (touchEvent.touches[1].clientX - this.previousTouches[1].x)) / 2,
        "movementY": (touchEvent.touches[0].clientY - this.previousTouches[0].y + (touchEvent.touches[1].clientY - this.previousTouches[1].y)) / 2,
        "deltaX": 0,
        "deltaY": 50 * scaleFactor,
        "deltaZ": 0,
        "deltaMode": WheelEvent.DOM_DELTA_PIXEL,
        "view": touchEvent.view,
        cancelable: true,
        bubbles: true
      });
      touchEvent.target.dispatchEvent(wheelEvent);
    }
    this.previousTouches = [];
    for (let i = 0; i < touchEvent.changedTouches.length; i++) {
      this.previousTouches.push(new Vector2(touchEvent.touches[i].clientX, touchEvent.touches[i].clientY));
    }
  }
  onMouseDown(event) {
  }
  onMouseUp(event) {
  }
  onMouseMove(event) {
  }
  onMouseWheel(event) {
  }
  onKeyDown(event) {
  }
  onKeyUp(event) {
  }
};

// node_modules/gophergfx/src/shaders/gouraud.vert
var gouraud_default = "#version 300 es\n\nprecision mediump float;\n\n#define POINT_LIGHT 0\n#define DIRECTIONAL_LIGHT 1\n\nconst int MAX_LIGHTS = 16;\n\nuniform mat4 modelMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 normalMatrix;\nuniform vec3 eyePosition;\n\nuniform int numLights;\nuniform int lightTypes[MAX_LIGHTS];\nuniform vec3 lightPositions[MAX_LIGHTS];\nuniform vec3 ambientIntensities[MAX_LIGHTS];\nuniform vec3 diffuseIntensities[MAX_LIGHTS];\nuniform vec3 specularIntensities[MAX_LIGHTS];\n\nuniform vec3 kAmbient;\nuniform vec3 kDiffuse;\nuniform vec3 kSpecular;\nuniform float shininess;\n\nin vec3 position;\nin vec3 normal;\nin vec4 color;\nin vec2 texCoord;\n\nout vec4 vertColor;\nout vec2 uv;\n\nvoid main() \n{\n    // Compute the vertex position in world space\n    vec3 worldPosition = (modelMatrix * vec4(position, 1)).xyz;\n\n    vec3 illumination = vec3(0, 0, 0);\n    for(int i=0; i < numLights; i++)\n    {\n        // Ambient component\n        illumination += kAmbient * ambientIntensities[i];\n        \n        // Compute the normal in world space\n        vec3 n = normalize((normalMatrix * vec4(normal, 0)).xyz);\n\n        // Compute the vector from the vertex position to the light\n        vec3 l;\n        if(lightTypes[i] == DIRECTIONAL_LIGHT)\n            l = normalize(lightPositions[i]);\n        else\n            l = normalize(lightPositions[i] - worldPosition);\n\n        // Diffuse component\n        float diffuseComponent = max(dot(n, l), 0.0);\n        illumination += diffuseComponent * kDiffuse * diffuseIntensities[i];\n\n        // Compute the vector from the vertex to the eye\n        vec3 e = normalize(eyePosition - worldPosition);\n\n        // Compute the light vector reflected about the normal\n        vec3 r = reflect(-l, n);\n\n        // Specular component\n        float specularComponent = pow(max(dot(e, r), 0.0), shininess);\n        illumination += specularComponent * kSpecular * specularIntensities[i];\n    }\n\n    vertColor = color;\n    vertColor.rgb *= illumination;\n\n    uv = texCoord.xy; \n\n    gl_Position = projectionMatrix * viewMatrix * vec4(worldPosition, 1);\n}";

// node_modules/gophergfx/src/shaders/gouraud.frag
var gouraud_default2 = "#version 300 es\n\nprecision mediump float;\n\nuniform int useTexture;\nuniform sampler2D textureImage;\n\nin vec4 vertColor;\nin vec2 uv;\n\nout vec4 fragColor;\n\nvoid main() \n{\n    fragColor = vertColor;\n\n    if(useTexture != 0)\n    {\n        fragColor *= texture(textureImage, uv);\n    }\n}";

// node_modules/gophergfx/src/materials/Material3.ts
var Side = /* @__PURE__ */ ((Side2) => {
  Side2[Side2["FRONT"] = 0] = "FRONT";
  Side2[Side2["BACK"] = 1] = "BACK";
  Side2[Side2["DOUBLE"] = 2] = "DOUBLE";
  return Side2;
})(Side || {});
var Material3 = class {
  constructor() {
    this.visible = true;
    this.side = 0 /* FRONT */;
    this.gl = GfxApp.getInstance().renderer.gl;
  }
  initialize() {
    if (this.side == 2 /* DOUBLE */) {
      this.gl.disable(this.gl.CULL_FACE);
      return;
    }
    this.gl.enable(this.gl.CULL_FACE);
    if (this.side == 0 /* FRONT */)
      this.gl.cullFace(this.gl.BACK);
    else
      this.gl.cullFace(this.gl.FRONT);
  }
};

// node_modules/gophergfx/src/materials/ShaderProgram.ts
var ShaderProgram = class {
  constructor(vertexSource, fragmentSource) {
    this.vertexSource = vertexSource;
    this.fragmentSource = fragmentSource;
    this.vertexShader = null;
    this.fragmentShader = null;
    this.shaderProgram = null;
    this.initialized = false;
  }
  initialize(gl) {
    if (this.initialized)
      return;
    this.initialized = true;
    this.vertexShader = this.createVertexShader(gl, this.vertexSource);
    this.fragmentShader = this.createFragmentShader(gl, this.fragmentSource);
    if (this.vertexShader && this.fragmentShader)
      this.shaderProgram = this.createShaderProgram(gl, this.vertexShader, this.fragmentShader);
  }
  createVertexShader(gl, source) {
    const shader = gl.createShader(gl.VERTEX_SHADER);
    if (!shader) {
      console.error("Error: unable to create vertex shader");
    } else {
      gl.shaderSource(shader, source);
      gl.compileShader(shader);
      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        console.error("Error: unable to load vertex shader");
        console.error(gl.getShaderInfoLog(shader));
      }
    }
    return shader;
  }
  createFragmentShader(gl, source) {
    const shader = gl.createShader(gl.FRAGMENT_SHADER);
    if (!shader) {
      console.error("Error: unable to create fragment shader");
    } else {
      gl.shaderSource(shader, source);
      gl.compileShader(shader);
      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        console.error("Error: unable to load fragment shader");
        console.error(gl.getShaderInfoLog(shader));
      }
    }
    return shader;
  }
  createShaderProgram(gl, vertexShader, fragmentShader) {
    let program = null;
    if (vertexShader && fragmentShader) {
      program = gl.createProgram();
      if (!program) {
        console.error("Error: could not create shader program");
        return null;
      }
      gl.attachShader(program, vertexShader);
      gl.attachShader(program, fragmentShader);
      gl.linkProgram(program);
      if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        console.error("Error: could not link shader program");
        console.error(gl.getProgramInfoLog(program));
        return null;
      }
    }
    return program;
  }
  getProgram() {
    return this.shaderProgram;
  }
  getAttribute(gl, attribute) {
    if (this.shaderProgram)
      return gl.getAttribLocation(this.shaderProgram, attribute);
    else
      return -1;
  }
  getUniform(gl, uniform) {
    if (this.shaderProgram)
      return gl.getUniformLocation(this.shaderProgram, uniform);
    else
      return null;
  }
};

// node_modules/gophergfx/src/materials/GouraudMaterial.ts
var _GouraudMaterial = class extends Material3 {
  constructor() {
    super();
    this.texture = null;
    this.ambientColor = new Color(1, 1, 1);
    this.diffuseColor = new Color(1, 1, 1);
    this.specularColor = new Color(0, 0, 0);
    this.shininess = 30;
    _GouraudMaterial.shader.initialize(this.gl);
    this.kAmbientUniform = _GouraudMaterial.shader.getUniform(this.gl, "kAmbient");
    this.kDiffuseUniform = _GouraudMaterial.shader.getUniform(this.gl, "kDiffuse");
    this.kSpecularUniform = _GouraudMaterial.shader.getUniform(this.gl, "kSpecular");
    this.shininessUniform = _GouraudMaterial.shader.getUniform(this.gl, "shininess");
    this.textureUniform = _GouraudMaterial.shader.getUniform(this.gl, "textureImage");
    this.useTextureUniform = _GouraudMaterial.shader.getUniform(this.gl, "useTexture");
    this.eyePositionUniform = _GouraudMaterial.shader.getUniform(this.gl, "eyePosition");
    this.viewUniform = _GouraudMaterial.shader.getUniform(this.gl, "viewMatrix");
    this.modelUniform = _GouraudMaterial.shader.getUniform(this.gl, "modelMatrix");
    this.projectionUniform = _GouraudMaterial.shader.getUniform(this.gl, "projectionMatrix");
    this.normalUniform = _GouraudMaterial.shader.getUniform(this.gl, "normalMatrix");
    this.numLightsUniform = _GouraudMaterial.shader.getUniform(this.gl, "numLights");
    this.lightTypesUniform = _GouraudMaterial.shader.getUniform(this.gl, "lightTypes");
    this.lightPositionsUniform = _GouraudMaterial.shader.getUniform(this.gl, "lightPositions");
    this.ambientIntensitiesUniform = _GouraudMaterial.shader.getUniform(this.gl, "ambientIntensities");
    this.diffuseIntensitiesUniform = _GouraudMaterial.shader.getUniform(this.gl, "diffuseIntensities");
    this.specularIntensitiesUniform = _GouraudMaterial.shader.getUniform(this.gl, "specularIntensities");
    this.positionAttribute = _GouraudMaterial.shader.getAttribute(this.gl, "position");
    this.normalAttribute = _GouraudMaterial.shader.getAttribute(this.gl, "normal");
    this.colorAttribute = _GouraudMaterial.shader.getAttribute(this.gl, "color");
    this.texCoordAttribute = _GouraudMaterial.shader.getAttribute(this.gl, "texCoord");
  }
  draw(mesh, transform, camera, lightManager) {
    if (!this.visible || mesh.triangleCount == 0)
      return;
    this.initialize();
    this.gl.useProgram(_GouraudMaterial.shader.getProgram());
    const cameraPosition = new Vector3();
    cameraPosition.applyMatrix(camera.worldMatrix);
    this.gl.uniform3f(this.eyePositionUniform, cameraPosition.x, cameraPosition.y, cameraPosition.z);
    this.gl.uniformMatrix4fv(this.modelUniform, false, transform.worldMatrix.mat);
    this.gl.uniformMatrix4fv(this.viewUniform, false, camera.viewMatrix.mat);
    this.gl.uniformMatrix4fv(this.projectionUniform, false, camera.projectionMatrix.mat);
    this.gl.uniformMatrix4fv(this.normalUniform, false, transform.worldMatrix.inverse().transpose().mat);
    this.gl.uniform3f(this.kAmbientUniform, this.ambientColor.r, this.ambientColor.g, this.ambientColor.b);
    this.gl.uniform3f(this.kDiffuseUniform, this.diffuseColor.r, this.diffuseColor.g, this.diffuseColor.b);
    this.gl.uniform3f(this.kSpecularUniform, this.specularColor.r, this.specularColor.g, this.specularColor.b);
    this.gl.uniform1f(this.shininessUniform, this.shininess);
    this.gl.uniform1i(this.numLightsUniform, lightManager.getNumLights());
    this.gl.uniform1iv(this.lightTypesUniform, lightManager.lightTypes);
    this.gl.uniform3fv(this.lightPositionsUniform, lightManager.lightPositions);
    this.gl.uniform3fv(this.ambientIntensitiesUniform, lightManager.ambientIntensities);
    this.gl.uniform3fv(this.diffuseIntensitiesUniform, lightManager.diffuseIntensities);
    this.gl.uniform3fv(this.specularIntensitiesUniform, lightManager.specularIntensities);
    this.gl.enableVertexAttribArray(this.positionAttribute);
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, mesh.positionBuffer);
    this.gl.vertexAttribPointer(this.positionAttribute, 3, this.gl.FLOAT, false, 0, 0);
    this.gl.enableVertexAttribArray(this.normalAttribute);
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, mesh.normalBuffer);
    this.gl.vertexAttribPointer(this.normalAttribute, 3, this.gl.FLOAT, false, 0, 0);
    this.gl.enableVertexAttribArray(this.colorAttribute);
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, mesh.colorBuffer);
    this.gl.vertexAttribPointer(this.colorAttribute, 4, this.gl.FLOAT, false, 0, 0);
    if (this.texture) {
      this.gl.uniform1i(this.useTextureUniform, 1);
      this.gl.activeTexture(this.gl.TEXTURE0 + this.texture.id);
      this.gl.bindTexture(this.gl.TEXTURE_2D, this.texture.texture);
      this.gl.uniform1i(this.textureUniform, this.texture.id);
      this.gl.enableVertexAttribArray(this.texCoordAttribute);
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, mesh.texCoordBuffer);
      this.gl.vertexAttribPointer(this.texCoordAttribute, 2, this.gl.FLOAT, false, 0, 0);
    } else {
      this.gl.uniform1i(this.useTextureUniform, 0);
    }
    this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, mesh.indexBuffer);
    this.gl.drawElements(this.gl.TRIANGLES, mesh.triangleCount * 3, this.gl.UNSIGNED_SHORT, 0);
  }
};
var GouraudMaterial = _GouraudMaterial;
GouraudMaterial.shader = new ShaderProgram(gouraud_default, gouraud_default2);

// node_modules/gophergfx/src/math/BoundingBox3.ts
var BoundingBox3 = class {
  constructor() {
    this.min = new Vector3();
    this.max = new Vector3();
  }
  copy(box) {
    this.min.copy(box.min);
    this.max.copy(box.max);
  }
};

// node_modules/gophergfx/src/math/BoundingSphere.ts
var BoundingSphere = class {
  constructor() {
    this.center = new Vector3();
    this.radius = 0;
  }
  copy(circle) {
    this.center.copy(circle.center);
    this.radius = circle.radius;
  }
};

// node_modules/gophergfx/src/geometry/3d/Mesh.ts
var Mesh = class extends Transform3 {
  constructor() {
    super();
    this.gl = GfxApp.getInstance().renderer.gl;
    this.positionBuffer = this.gl.createBuffer();
    this.normalBuffer = this.gl.createBuffer();
    this.colorBuffer = this.gl.createBuffer();
    this.indexBuffer = this.gl.createBuffer();
    this.texCoordBuffer = this.gl.createBuffer();
    this.vertexCount = 0;
    this.triangleCount = 0;
    this.material = new GouraudMaterial();
    this.boundingBox = new BoundingBox3();
    this.boundingSphere = new BoundingSphere();
  }
  draw(parent, camera, lightManager) {
    if (!this.visible)
      return;
    this.material.draw(this, this, camera, lightManager);
    this.children.forEach((elem) => {
      elem.draw(this, camera, lightManager);
    });
  }
  setVertices(vertices, usage = this.gl.STATIC_DRAW) {
    if (vertices.length > 0) {
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.positionBuffer);
      let vArray;
      if (typeof vertices[0] === "number") {
        vArray = vertices;
      } else {
        vArray = [];
        vertices.forEach((elem) => {
          vArray.push(elem.x, elem.y, elem.z);
        });
      }
      this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(vArray), usage);
      this.vertexCount = vArray.length / 3;
      this.computeBounds(vertices);
    }
  }
  setNormals(normals, usage = this.gl.STATIC_DRAW) {
    if (normals.length > 0) {
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.normalBuffer);
      if (typeof normals[0] === "number") {
        this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(normals), usage);
      } else {
        const nArray = [];
        normals.forEach((elem) => {
          nArray.push(elem.x, elem.y, elem.z);
        });
        this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(nArray), usage);
      }
    }
  }
  setColors(colors, usage = this.gl.STATIC_DRAW) {
    if (colors.length > 0) {
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.colorBuffer);
      if (typeof colors[0] === "number") {
        this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(colors), usage);
      } else {
        const cArray = [];
        colors.forEach((elem) => {
          cArray.push(elem.r, elem.g, elem.b, elem.a);
        });
        this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(cArray), usage);
      }
    }
  }
  setTextureCoordinates(texCoords, usage = this.gl.STATIC_DRAW) {
    if (texCoords.length > 0) {
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.texCoordBuffer);
      if (typeof texCoords[0] === "number") {
        this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(texCoords), usage);
      } else {
        const tArray = [];
        texCoords.forEach((elem) => {
          tArray.push(elem.x, elem.y);
        });
        this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(tArray), usage);
      }
    }
  }
  setIndices(indices, usage = this.gl.STATIC_DRAW) {
    if (indices.length > 0) {
      this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
      if (typeof indices[0] === "number") {
        this.triangleCount = indices.length / 3;
        this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), usage);
      } else {
        this.triangleCount = indices.length;
        const iArray = [];
        indices.forEach((elem) => {
          iArray.push(elem.x, elem.y, elem.z);
        });
        this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(iArray), usage);
      }
    }
  }
  setArrayBuffer(values, buffer, usage = this.gl.STATIC_DRAW) {
    if (values.length > 0) {
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, buffer);
      if (typeof values[0] === "number") {
        this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(values), usage);
      } else {
        const nArray = [];
        values.forEach((elem) => {
          nArray.push(elem.x, elem.y, elem.z);
        });
        this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(nArray), usage);
      }
    }
  }
  getVertices() {
    const vertexArray = new Float32Array(this.vertexCount * 3);
    this.gl.bindBuffer(this.gl.COPY_READ_BUFFER, this.positionBuffer);
    this.gl.getBufferSubData(this.gl.COPY_READ_BUFFER, 0, vertexArray);
    return [...vertexArray];
  }
  getNormals() {
    const normalArray = new Float32Array(this.vertexCount * 3);
    this.gl.bindBuffer(this.gl.COPY_READ_BUFFER, this.normalBuffer);
    this.gl.getBufferSubData(this.gl.COPY_READ_BUFFER, 0, normalArray);
    return [...normalArray];
  }
  getColors() {
    const colorArray = new Float32Array(this.vertexCount * 4);
    this.gl.bindBuffer(this.gl.COPY_READ_BUFFER, this.colorBuffer);
    this.gl.getBufferSubData(this.gl.COPY_READ_BUFFER, 0, colorArray);
    return [...colorArray];
  }
  getTextureCoordinates() {
    const texCoordArray = new Float32Array(this.vertexCount * 2);
    this.gl.bindBuffer(this.gl.COPY_READ_BUFFER, this.texCoordBuffer);
    this.gl.getBufferSubData(this.gl.COPY_READ_BUFFER, 0, texCoordArray);
    return [...texCoordArray];
  }
  getIndices() {
    const indexArray = new Uint16Array(this.triangleCount * 3);
    this.gl.bindBuffer(this.gl.COPY_READ_BUFFER, this.indexBuffer);
    this.gl.getBufferSubData(this.gl.COPY_READ_BUFFER, 0, indexArray);
    return [...indexArray];
  }
  getArrayBuffer(buffer) {
    const valueArray = new Float32Array(this.vertexCount * 3);
    this.gl.bindBuffer(this.gl.COPY_READ_BUFFER, buffer);
    this.gl.getBufferSubData(this.gl.COPY_READ_BUFFER, 0, valueArray);
    return [...valueArray];
  }
  createDefaultVertexColors() {
    const colors = [];
    for (let i = 0; i < this.vertexCount; i++)
      colors.push(1, 1, 1, 1);
    this.setColors(colors);
  }
  computeBounds(vertices) {
    if (!vertices) {
      vertices = this.getVertices();
    }
    if (vertices.length == 0)
      return;
    if (typeof vertices[0] === "number") {
      const vArray = vertices;
      this.boundingBox.max.set(vArray[0], vArray[1], vArray[2]);
      this.boundingBox.min.set(vArray[0], vArray[1], vArray[2]);
      for (let i = 0; i < vArray.length; i += 3) {
        if (vArray[i] > this.boundingBox.max.x)
          this.boundingBox.max.x = vArray[i];
        if (vArray[i] < this.boundingBox.min.x)
          this.boundingBox.min.x = vArray[i];
        if (vArray[i + 1] > this.boundingBox.max.y)
          this.boundingBox.max.y = vArray[i + 1];
        if (vArray[i + 1] < this.boundingBox.min.y)
          this.boundingBox.min.y = vArray[i + 1];
        if (vArray[i + 2] > this.boundingBox.max.z)
          this.boundingBox.max.z = vArray[i + 2];
        if (vArray[i + 2] < this.boundingBox.min.z)
          this.boundingBox.min.z = vArray[i + 2];
      }
    } else {
      this.boundingBox.max.copy(vertices[0]);
      this.boundingBox.min.copy(vertices[0]);
      vertices.forEach((elem) => {
        if (elem.x > this.boundingBox.max.x)
          this.boundingBox.max.x = elem.x;
        if (elem.x < this.boundingBox.min.x)
          this.boundingBox.min.x = elem.x;
        if (elem.y > this.boundingBox.max.y)
          this.boundingBox.max.y = elem.y;
        if (elem.y < this.boundingBox.min.y)
          this.boundingBox.min.y = elem.y;
        if (elem.z > this.boundingBox.max.z)
          this.boundingBox.max.z = elem.z;
        if (elem.z < this.boundingBox.min.z)
          this.boundingBox.min.z = elem.z;
      });
    }
    this.boundingSphere.center.copy(this.boundingBox.min);
    this.boundingSphere.center.add(this.boundingBox.max);
    this.boundingSphere.center.multiplyScalar(0.5);
    this.boundingSphere.radius = 0;
    if (typeof vertices[0] === "number") {
      const vArray = vertices;
      for (let i = 0; i < vArray.length; i += 3) {
        const distance = Math.sqrt(
          (vArray[i] - this.boundingSphere.center.x) * (vArray[i] - this.boundingSphere.center.x) + (vArray[i + 1] - this.boundingSphere.center.y) * (vArray[i + 1] - this.boundingSphere.center.y) + (vArray[i + 2] - this.boundingSphere.center.z) * (vArray[i + 2] - this.boundingSphere.center.z)
        );
        if (distance > this.boundingSphere.radius)
          this.boundingSphere.radius = distance;
      }
    } else {
      vertices.forEach((elem) => {
        const distance = elem.distanceTo(this.boundingSphere.center);
        if (distance > this.boundingSphere.radius)
          this.boundingSphere.radius = distance;
      });
    }
  }
};

// node_modules/gophergfx/src/geometry/3d/MeshInstance.ts
var MeshInstance = class extends Transform3 {
  constructor(baseMesh, copyTransform = true) {
    super();
    this.baseMesh = baseMesh;
    this.material = baseMesh.material;
    if (copyTransform) {
      this.position.copy(baseMesh.position);
      this.rotation.copy(baseMesh.rotation);
      this.scale.copy(baseMesh.scale);
    }
  }
  getBaseMesh() {
    return this.baseMesh;
  }
  draw(parent, camera, lightManager) {
    if (!this.visible)
      return;
    this.material.draw(this.baseMesh, this, camera, lightManager);
    this.children.forEach((elem) => {
      elem.draw(this, camera, lightManager);
    });
  }
};

// node_modules/gophergfx/src/geometry/3d/BoxMesh.ts
var BoxMesh = class extends Mesh {
  constructor(width = 1, height = 1, depth = 1) {
    super();
    this.width = width;
    this.height = height;
    this.depth = depth;
    this.createVertices(this.width, this.height, this.depth);
    this.createNormals();
    this.createTextureCoords();
    this.createIndices();
    this.createDefaultVertexColors();
  }
  setLine(startPoint, endPoint, thickness) {
    this.position.copy(startPoint);
    this.lookAt(endPoint);
    const distance = Vector3.distanceBetween(startPoint, endPoint);
    this.translateZ(-distance / 2);
    this.scale.x = thickness;
    this.scale.y = thickness;
    this.scale.z = distance;
  }
  createVertices(width, height, depth) {
    const vertices = [];
    vertices.push(-width / 2, -height / 2, depth / 2);
    vertices.push(width / 2, -height / 2, depth / 2);
    vertices.push(width / 2, height / 2, depth / 2);
    vertices.push(-width / 2, height / 2, depth / 2);
    vertices.push(-width / 2, -height / 2, -depth / 2);
    vertices.push(width / 2, -height / 2, -depth / 2);
    vertices.push(width / 2, height / 2, -depth / 2);
    vertices.push(-width / 2, height / 2, -depth / 2);
    vertices.push(-width / 2, -height / 2, -depth / 2);
    vertices.push(-width / 2, -height / 2, depth / 2);
    vertices.push(-width / 2, height / 2, depth / 2);
    vertices.push(-width / 2, height / 2, -depth / 2);
    vertices.push(width / 2, -height / 2, -depth / 2);
    vertices.push(width / 2, -height / 2, depth / 2);
    vertices.push(width / 2, height / 2, depth / 2);
    vertices.push(width / 2, height / 2, -depth / 2);
    vertices.push(-width / 2, height / 2, depth / 2);
    vertices.push(width / 2, height / 2, depth / 2);
    vertices.push(width / 2, height / 2, -depth / 2);
    vertices.push(-width / 2, height / 2, -depth / 2);
    vertices.push(-width / 2, -height / 2, depth / 2);
    vertices.push(width / 2, -height / 2, depth / 2);
    vertices.push(width / 2, -height / 2, -depth / 2);
    vertices.push(-width / 2, -height / 2, -depth / 2);
    this.setVertices(vertices);
  }
  createNormals() {
    const normals = [];
    normals.push(0, 0, 1);
    normals.push(0, 0, 1);
    normals.push(0, 0, 1);
    normals.push(0, 0, 1);
    normals.push(0, 0, -1);
    normals.push(0, 0, -1);
    normals.push(0, 0, -1);
    normals.push(0, 0, -1);
    normals.push(-1, 0, 0);
    normals.push(-1, 0, 0);
    normals.push(-1, 0, 0);
    normals.push(-1, 0, 0);
    normals.push(1, 0, 0);
    normals.push(1, 0, 0);
    normals.push(1, 0, 0);
    normals.push(1, 0, 0);
    normals.push(0, 1, 0);
    normals.push(0, 1, 0);
    normals.push(0, 1, 0);
    normals.push(0, 1, 0);
    normals.push(0, -1, 0);
    normals.push(0, -1, 0);
    normals.push(0, -1, 0);
    normals.push(0, -1, 0);
    this.setNormals(normals);
  }
  createIndices() {
    const indices = [];
    indices.push(0, 1, 2);
    indices.push(2, 3, 0);
    indices.push(4, 6, 5);
    indices.push(6, 4, 7);
    indices.push(8, 9, 10);
    indices.push(10, 11, 8);
    indices.push(12, 14, 13);
    indices.push(14, 12, 15);
    indices.push(16, 17, 18);
    indices.push(18, 19, 16);
    indices.push(20, 22, 21);
    indices.push(22, 20, 23);
    this.setIndices(indices);
  }
  createTextureCoords() {
    const uvs = [];
    uvs.push(0, 1);
    uvs.push(1, 1);
    uvs.push(1, 0);
    uvs.push(0, 0);
    uvs.push(1, 1);
    uvs.push(0, 1);
    uvs.push(0, 0);
    uvs.push(1, 0);
    uvs.push(0, 1);
    uvs.push(1, 1);
    uvs.push(1, 0);
    uvs.push(0, 0);
    uvs.push(1, 1);
    uvs.push(0, 1);
    uvs.push(0, 0);
    uvs.push(1, 0);
    uvs.push(0, 1);
    uvs.push(1, 1);
    uvs.push(1, 0);
    uvs.push(0, 0);
    uvs.push(1, 1);
    uvs.push(0, 1);
    uvs.push(0, 0);
    uvs.push(1, 0);
    this.setTextureCoordinates(uvs);
  }
};

// node_modules/gophergfx/src/geometry/3d/SphereMesh.ts
var SphereMesh = class extends Mesh {
  constructor(radius = 1, subdivisions = 3) {
    super();
    this.radius = radius;
    this.subdivisions = subdivisions;
    this.createSphere(this.radius, this.subdivisions);
  }
  createSphere(radius, subdivisions) {
    let vertices = [];
    let indices = [];
    const normals = [];
    const texCoords = [];
    const phi = (1 + Math.sqrt(5)) * 0.5;
    const a = 1;
    const b = 1 / phi;
    vertices.push(new Vector3(0, b, -a));
    vertices.push(new Vector3(b, a, 0));
    vertices.push(new Vector3(-b, a, 0));
    vertices.push(new Vector3(0, b, a));
    vertices.push(new Vector3(0, -b, a));
    vertices.push(new Vector3(-a, 0, b));
    vertices.push(new Vector3(0, -b, -a));
    vertices.push(new Vector3(a, 0, -b));
    vertices.push(new Vector3(a, 0, b));
    vertices.push(new Vector3(-a, 0, -b));
    vertices.push(new Vector3(b, -a, 0));
    vertices.push(new Vector3(-b, -a, 0));
    for (let i = 0; i < vertices.length; i++) {
      vertices[i].normalize();
    }
    indices.push(2, 1, 0);
    indices.push(1, 2, 3);
    indices.push(5, 4, 3);
    indices.push(4, 8, 3);
    indices.push(7, 6, 0);
    indices.push(6, 9, 0);
    indices.push(11, 10, 4);
    indices.push(10, 11, 6);
    indices.push(9, 5, 2);
    indices.push(5, 9, 11);
    indices.push(8, 7, 1);
    indices.push(7, 8, 10);
    indices.push(2, 5, 3);
    indices.push(8, 1, 3);
    indices.push(9, 2, 0);
    indices.push(1, 7, 0);
    indices.push(11, 9, 6);
    indices.push(7, 10, 6);
    indices.push(5, 11, 4);
    indices.push(10, 8, 4);
    for (let div = 0; div < subdivisions; div++) {
      const newIndices = [];
      for (let i = 0; i < indices.length / 3; i++) {
        const index = i * 3;
        const centroids = this.createCentroids(vertices, indices[index], indices[index + 1], indices[index + 2]);
        vertices.push(...centroids);
        const triangles = this.subdivide(
          indices[index],
          indices[index + 1],
          indices[index + 2],
          vertices.length - 3,
          vertices.length - 2,
          vertices.length - 1
        );
        newIndices.push(...triangles);
      }
      indices = newIndices;
    }
    for (let i = 0; i < vertices.length; i++) {
      vertices[i].multiplyScalar(radius);
    }
    [vertices, indices] = this.mergeSharedVertices(vertices, indices);
    for (let i = 0; i < vertices.length; i++) {
      normals.push(Vector3.normalize(vertices[i]));
      const v = 1 - (vertices[i].y + radius) / (2 * radius);
      const direction = new Vector3(vertices[i].x, 0, vertices[i].z);
      direction.normalize();
      let angle = Math.acos(Vector3.FORWARD.dot(direction));
      if (direction.x > 0)
        angle = Math.PI * 2 - angle;
      const u = angle / (Math.PI * 2);
      texCoords.push(u, v);
    }
    const indicesLength = indices.length;
    for (let i = 0; i < indicesLength; i += 3) {
      if (this.isSeamVertex(i, vertices, indices)) {
        if (this.isEndVertex(i + 1, vertices, indices) && this.isEndVertex(i + 2, vertices, indices)) {
          vertices.push(Vector3.copy(vertices[indices[i]]));
          normals.push(Vector3.normalize(vertices[indices[i]]));
          texCoords.push(1, texCoords[indices[i] * 2 + 1]);
          indices[i] = vertices.length - 1;
        } else if (this.isEndVertex(i + 1, vertices, indices)) {
          vertices.push(Vector3.copy(vertices[indices[i]]));
          normals.push(Vector3.normalize(vertices[indices[i]]));
          texCoords.push(1, texCoords[indices[i] * 2 + 1]);
          vertices.push(Vector3.copy(vertices[indices[i + 2]]));
          normals.push(Vector3.normalize(vertices[indices[i + 2]]));
          texCoords.push(1, texCoords[indices[i + 2] * 2 + 1]);
          indices[i] = vertices.length - 2;
          indices[i + 2] = vertices.length - 1;
        } else if (this.isEndVertex(i + 2, vertices, indices)) {
          vertices.push(Vector3.copy(vertices[indices[i]]));
          normals.push(Vector3.normalize(vertices[indices[i]]));
          texCoords.push(1, texCoords[indices[i] * 2 + 1]);
          vertices.push(Vector3.copy(vertices[indices[i + 1]]));
          normals.push(Vector3.normalize(vertices[indices[i + 1]]));
          texCoords.push(1, texCoords[indices[i + 1] * 2 + 1]);
          indices[i] = vertices.length - 2;
          indices[i + 1] = vertices.length - 1;
        }
      } else if (this.isSeamVertex(i + 1, vertices, indices)) {
        if (this.isEndVertex(i, vertices, indices) && this.isEndVertex(i + 2, vertices, indices)) {
          vertices.push(Vector3.copy(vertices[indices[i + 1]]));
          normals.push(Vector3.normalize(vertices[indices[i + 1]]));
          texCoords.push(1, texCoords[indices[i + 1] * 2 + 1]);
          indices[i + 1] = vertices.length - 1;
        } else if (this.isEndVertex(i, vertices, indices)) {
          vertices.push(Vector3.copy(vertices[indices[i + 1]]));
          normals.push(Vector3.normalize(vertices[indices[i + 1]]));
          texCoords.push(1, texCoords[indices[i + 1] * 2 + 1]);
          vertices.push(Vector3.copy(vertices[indices[i + 2]]));
          normals.push(Vector3.normalize(vertices[indices[i + 2]]));
          texCoords.push(1, texCoords[indices[i + 2] * 2 + 1]);
          indices[i + 1] = vertices.length - 2;
          indices[i + 2] = vertices.length - 1;
        } else if (this.isEndVertex(i + 2, vertices, indices)) {
          vertices.push(Vector3.copy(vertices[indices[i]]));
          normals.push(Vector3.normalize(vertices[indices[i]]));
          texCoords.push(1, texCoords[indices[i] * 2 + 1]);
          vertices.push(Vector3.copy(vertices[indices[i + 1]]));
          normals.push(Vector3.normalize(vertices[indices[i + 1]]));
          texCoords.push(1, texCoords[indices[i + 1] * 2 + 1]);
          indices[i] = vertices.length - 2;
          indices[i + 1] = vertices.length - 1;
        }
      } else if (this.isSeamVertex(i + 2, vertices, indices)) {
        if (this.isEndVertex(i, vertices, indices) && this.isEndVertex(i + 1, vertices, indices)) {
          vertices.push(Vector3.copy(vertices[indices[i + 2]]));
          normals.push(Vector3.normalize(vertices[indices[i + 2]]));
          texCoords.push(1, texCoords[indices[i + 2] * 2 + 1]);
          indices[i + 2] = vertices.length - 1;
        } else if (this.isEndVertex(i, vertices, indices)) {
          vertices.push(Vector3.copy(vertices[indices[i + 1]]));
          normals.push(Vector3.normalize(vertices[indices[i + 1]]));
          texCoords.push(1, texCoords[indices[i + 1] * 2 + 1]);
          vertices.push(Vector3.copy(vertices[indices[i + 2]]));
          normals.push(Vector3.normalize(vertices[indices[i + 2]]));
          texCoords.push(1, texCoords[indices[i + 2] * 2 + 1]);
          indices[i + 1] = vertices.length - 2;
          indices[i + 2] = vertices.length - 1;
        } else if (this.isEndVertex(i + 1, vertices, indices)) {
          vertices.push(Vector3.copy(vertices[indices[i]]));
          normals.push(Vector3.normalize(vertices[indices[i]]));
          texCoords.push(1, texCoords[indices[i] * 2 + 1]);
          vertices.push(Vector3.copy(vertices[indices[i + 2]]));
          normals.push(Vector3.normalize(vertices[indices[i + 2]]));
          texCoords.push(1, texCoords[indices[i + 2] * 2 + 1]);
          indices[i] = vertices.length - 2;
          indices[i + 2] = vertices.length - 1;
        }
      }
    }
    this.setVertices(vertices);
    this.setNormals(normals);
    this.setTextureCoordinates(texCoords);
    this.setIndices(indices);
    this.createDefaultVertexColors();
  }
  isEndVertex(i, vertices, indices) {
    if (vertices[indices[i]].x > 0)
      return true;
    else
      return false;
  }
  isSeamVertex(i, vertices, indices) {
    if (vertices[indices[i]].x == 0 && vertices[indices[i]].z <= 0)
      return true;
    else
      return false;
  }
  createCentroids(vertices, v1, v2, v3) {
    const centroids = [];
    const centroid1 = Vector3.add(vertices[v1], vertices[v2]);
    centroid1.divideScalar(2);
    centroid1.normalize();
    centroids.push(centroid1);
    const centroid2 = Vector3.add(vertices[v2], vertices[v3]);
    centroid2.divideScalar(2);
    centroid2.normalize();
    centroids.push(centroid2);
    const centroid3 = Vector3.add(vertices[v3], vertices[v1]);
    centroid3.divideScalar(2);
    centroid3.normalize();
    centroids.push(centroid3);
    return centroids;
  }
  subdivide(v1, v2, v3, c1, c2, c3) {
    const triangles = [];
    triangles.push(v1, c1, c3);
    triangles.push(v2, c2, c1);
    triangles.push(v3, c3, c2);
    triangles.push(c1, c2, c3);
    return triangles;
  }
  mergeSharedVertices(vertices, indices) {
    const newVertices = [];
    const newIndices = [];
    indices.forEach((elem) => {
      newIndices.push(elem);
    });
    for (let i = 0; i < vertices.length; i++) {
      let duplicate = false;
      for (let j = 0; j < newVertices.length; j++) {
        if (vertices[i].equals(newVertices[j])) {
          for (let k = 0; k < indices.length; k++) {
            if (indices[k] == i)
              newIndices[k] = j;
          }
          duplicate = true;
        }
      }
      if (!duplicate) {
        newVertices.push(vertices[i]);
        for (let k = 0; k < indices.length; k++) {
          if (indices[k] == i)
            newIndices[k] = newVertices.length - 1;
        }
      }
    }
    return [newVertices, newIndices];
  }
};

// node_modules/gophergfx/src/geometry/3d/PlaneMesh.ts
var PlaneMesh = class extends Mesh {
  constructor(width = 1, height = 1) {
    super();
    this.width = width;
    this.height = height;
    this.createVertices(this.width, this.height);
    this.createNormals();
    this.createTextureCoords();
    this.createIndices();
    this.createDefaultVertexColors();
  }
  createVertices(width, height) {
    const vertices = [];
    vertices.push(-width / 2, -height / 2, 0);
    vertices.push(width / 2, -height / 2, 0);
    vertices.push(width / 2, height / 2, 0);
    vertices.push(-width / 2, height / 2, 0);
    this.setVertices(vertices);
  }
  createNormals() {
    const normals = [];
    normals.push(0, 0, -1);
    normals.push(0, 0, -1);
    normals.push(0, 0, -1);
    normals.push(0, 0, -1);
    this.setNormals(normals);
  }
  createIndices() {
    const indices = [];
    indices.push(0, 2, 1);
    indices.push(2, 0, 3);
    this.setIndices(indices);
  }
  createTextureCoords() {
    const uvs = [];
    uvs.push(1, 1);
    uvs.push(0, 1);
    uvs.push(0, 0);
    uvs.push(1, 0);
    this.setTextureCoordinates(uvs);
  }
};

// node_modules/gophergfx/src/shaders/shape.vert
var shape_default = "#version 300 es\n\nprecision mediump float;\n\nuniform mat3 modelMatrix;\nuniform float layer;\n\nin vec2 position;\nin vec4 color;\nin vec2 texCoord;\n\nout vec4 vertColor;\nout vec2 uv;\n\nvoid main() \n{\n    vertColor = color;\n    uv = texCoord.xy; \n    vec3 worldPosition = modelMatrix * vec3(position, 1);\n    gl_Position = vec4(worldPosition.x, worldPosition.y, layer, 1);\n}";

// node_modules/gophergfx/src/shaders/shape.frag
var shape_default2 = "#version 300 es\n\nprecision mediump float;\n\nuniform vec4 color;\nuniform int useTexture;\nuniform sampler2D textureImage;\n\nin vec4 vertColor;\nin vec2 uv;\n\nout vec4 fragColor;\n\nvoid main() \n{\n    fragColor = color * vertColor;\n\n    if(useTexture != 0)\n    {\n        fragColor *= texture(textureImage, uv);\n    }\n}";

// node_modules/gophergfx/src/materials/Material2.ts
var _Material2 = class {
  constructor() {
    this.gl = GfxApp.getInstance().renderer.gl;
    this.visible = true;
    this.color = new Color(1, 1, 1);
    this.drawMode = this.gl.LINE_LOOP;
    this.texture = null;
    _Material2.shader.initialize(this.gl);
    this.colorUniform = _Material2.shader.getUniform(this.gl, "color");
    this.modelUniform = _Material2.shader.getUniform(this.gl, "modelMatrix");
    this.layerUniform = _Material2.shader.getUniform(this.gl, "layer");
    this.textureUniform = _Material2.shader.getUniform(this.gl, "textureImage");
    this.useTextureUniform = _Material2.shader.getUniform(this.gl, "useTexture");
    this.positionAttribute = _Material2.shader.getAttribute(this.gl, "position");
    this.colorAttribute = _Material2.shader.getAttribute(this.gl, "color");
    this.texCoordAttribute = _Material2.shader.getAttribute(this.gl, "texCoord");
  }
  copy(mat) {
    this.visible = mat.visible;
    this.color.copy(mat.color);
    this.drawMode = mat.drawMode;
    this.texture = mat.texture;
  }
  draw(shape, transform) {
    if (!this.visible || shape.vertexCount == 0)
      return;
    this.gl.useProgram(_Material2.shader.getProgram());
    this.gl.uniformMatrix3fv(this.modelUniform, false, transform.worldMatrix.mat);
    this.gl.uniform4f(this.colorUniform, this.color.r, this.color.g, this.color.b, this.color.a);
    this.gl.uniform1f(this.layerUniform, transform.layer);
    this.gl.enableVertexAttribArray(this.colorAttribute);
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, shape.colorBuffer);
    this.gl.vertexAttribPointer(this.colorAttribute, 4, this.gl.FLOAT, false, 0, 0);
    this.gl.enableVertexAttribArray(this.positionAttribute);
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, shape.positionBuffer);
    this.gl.vertexAttribPointer(this.positionAttribute, 2, this.gl.FLOAT, false, 0, 0);
    if (this.texture) {
      this.gl.uniform1i(this.useTextureUniform, 1);
      this.gl.activeTexture(this.gl.TEXTURE0 + this.texture.id);
      this.gl.bindTexture(this.gl.TEXTURE_2D, this.texture.texture);
      this.gl.uniform1i(this.textureUniform, this.texture.id);
      this.gl.enableVertexAttribArray(this.texCoordAttribute);
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, shape.texCoordBuffer);
      this.gl.vertexAttribPointer(this.texCoordAttribute, 2, this.gl.FLOAT, false, 0, 0);
    } else {
      this.gl.uniform1i(this.useTextureUniform, 0);
    }
    this.gl.drawArrays(this.drawMode, 0, shape.vertexCount);
  }
};
var Material2 = _Material2;
Material2.shader = new ShaderProgram(shape_default, shape_default2);

// node_modules/gophergfx/src/geometry/2d/Shape.ts
var Shape = class extends Transform2 {
  constructor() {
    super();
    this.gl = GfxApp.getInstance().renderer.gl;
    this.positionBuffer = this.gl.createBuffer();
    this.colorBuffer = this.gl.createBuffer();
    this.texCoordBuffer = this.gl.createBuffer();
    this.vertexCount = 0;
    this.material = new Material2();
  }
  draw(parent) {
    if (!this.visible)
      return;
    this.material.draw(this, this);
    this.children.forEach((elem) => {
      elem.draw(this);
    });
  }
  setVertices(vertices, usage = this.gl.STATIC_DRAW) {
    if (vertices.length > 0) {
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.positionBuffer);
      let vArray;
      if (typeof vertices[0] === "number") {
        vArray = vertices;
      } else {
        vArray = [];
        vertices.forEach((elem) => {
          vArray.push(elem.x, elem.y);
        });
      }
      this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(vArray), usage);
      this.vertexCount = vArray.length / 2;
      this.computeBounds(vertices);
    }
  }
  setColors(colors, usage = this.gl.STATIC_DRAW) {
    if (colors.length > 0) {
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.colorBuffer);
      if (typeof colors[0] === "number") {
        this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(colors), usage);
      } else {
        const cArray = [];
        colors.forEach((elem) => {
          cArray.push(elem.r, elem.g, elem.b, elem.a);
        });
        this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(cArray), usage);
      }
    }
  }
  setTextureCoordinates(texCoords, usage = this.gl.STATIC_DRAW) {
    if (texCoords.length > 0) {
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.texCoordBuffer);
      if (typeof texCoords[0] === "number") {
        this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(texCoords), usage);
      } else {
        const tArray = [];
        texCoords.forEach((elem) => {
          tArray.push(elem.x, elem.y);
        });
        this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(tArray), usage);
      }
    }
  }
  getVertices() {
    const vertexArray = new Float32Array(this.vertexCount * 2);
    this.gl.bindBuffer(this.gl.COPY_READ_BUFFER, this.positionBuffer);
    this.gl.getBufferSubData(this.gl.COPY_READ_BUFFER, 0, vertexArray);
    return [...vertexArray];
  }
  getColors() {
    const colorArray = new Float32Array(this.vertexCount * 4);
    this.gl.bindBuffer(this.gl.COPY_READ_BUFFER, this.colorBuffer);
    this.gl.getBufferSubData(this.gl.COPY_READ_BUFFER, 0, colorArray);
    return [...colorArray];
  }
  getTextureCoordinates() {
    const texCoordArray = new Float32Array(this.vertexCount * 2);
    this.gl.bindBuffer(this.gl.COPY_READ_BUFFER, this.texCoordBuffer);
    this.gl.getBufferSubData(this.gl.COPY_READ_BUFFER, 0, texCoordArray);
    return [...texCoordArray];
  }
  createDefaultVertexColors() {
    const colors = [];
    for (let i = 0; i < this.vertexCount; i++)
      colors.push(1, 1, 1, 1);
    this.setColors(colors);
  }
  computeBounds(vertices) {
    if (!vertices) {
      vertices = this.getVertices();
    }
    if (vertices.length == 0)
      return;
    if (typeof vertices[0] === "number") {
      const vArray = vertices;
      this.boundingBox.max.set(vArray[0], vArray[1]);
      this.boundingBox.min.set(vArray[0], vArray[1]);
      for (let i = 0; i < vArray.length; i += 3) {
        if (vArray[i] > this.boundingBox.max.x)
          this.boundingBox.max.x = vArray[i];
        if (vArray[i] < this.boundingBox.min.x)
          this.boundingBox.min.x = vArray[i];
        if (vArray[i + 1] > this.boundingBox.max.y)
          this.boundingBox.max.y = vArray[i + 1];
        if (vArray[i + 1] < this.boundingBox.min.y)
          this.boundingBox.min.y = vArray[i + 1];
      }
    } else {
      this.boundingBox.max.copy(vertices[0]);
      this.boundingBox.min.copy(vertices[0]);
      vertices.forEach((elem) => {
        if (elem.x > this.boundingBox.max.x)
          this.boundingBox.max.x = elem.x;
        if (elem.x < this.boundingBox.min.x)
          this.boundingBox.min.x = elem.x;
        if (elem.y > this.boundingBox.max.y)
          this.boundingBox.max.y = elem.y;
        if (elem.y < this.boundingBox.min.y)
          this.boundingBox.min.y = elem.y;
      });
    }
    this.boundingCircle.center.copy(this.boundingBox.min);
    this.boundingCircle.center.add(this.boundingBox.max);
    this.boundingCircle.center.multiplyScalar(0.5);
    this.boundingCircle.radius = 0;
    if (typeof vertices[0] === "number") {
      const vArray = vertices;
      for (let i = 0; i < vArray.length; i += 3) {
        const distance = Math.sqrt(
          (vArray[i] - this.boundingCircle.center.x) * (vArray[i] - this.boundingCircle.center.x) + (vArray[i + 1] - this.boundingCircle.center.y) * (vArray[i + 1] - this.boundingCircle.center.y)
        );
        if (distance > this.boundingCircle.radius)
          this.boundingCircle.radius = distance;
      }
    } else {
      vertices.forEach((elem) => {
        const distance = elem.distanceTo(this.boundingCircle.center);
        if (distance > this.boundingCircle.radius)
          this.boundingCircle.radius = distance;
      });
    }
  }
};

// node_modules/gophergfx/src/geometry/2d/ShapeInstance.ts
var ShapeInstance = class extends Transform2 {
  constructor(baseShape, copyTransform = true) {
    super();
    this.baseShape = baseShape;
    this.boundingBox = baseShape.boundingBox;
    this.boundingCircle = baseShape.boundingCircle;
    this.material = baseShape.material;
    if (copyTransform) {
      this.position.copy(baseShape.position);
      this.rotation = baseShape.rotation;
      this.scale.copy(baseShape.scale);
      this.layer = baseShape.layer;
    }
  }
  getBaseShape() {
    return this.baseShape;
  }
  draw(parent) {
    if (!this.visible)
      return;
    this.material.draw(this.baseShape, this);
    this.children.forEach((elem) => {
      elem.draw(this);
    });
  }
};

// node_modules/gophergfx/src/geometry/2d/Rectangle.ts
var Rectangle = class extends Shape {
  constructor(width = 1, height = 1) {
    super();
    this.width = width;
    this.height = height;
    this.material.drawMode = this.gl.TRIANGLE_STRIP;
    this.createVertices(this.width, this.height);
    this.createTextureCoordinates();
    this.createDefaultVertexColors();
  }
  createVertices(width, height) {
    const vertices = [];
    vertices.push(-width / 2, height / 2);
    vertices.push(-width / 2, -height / 2);
    vertices.push(width / 2, height / 2);
    vertices.push(width / 2, -height / 2);
    this.setVertices(vertices);
  }
  createTextureCoordinates() {
    const uvs = [];
    uvs.push(0, 0);
    uvs.push(0, 1);
    uvs.push(1, 0);
    uvs.push(1, 1);
    this.setTextureCoordinates(uvs);
  }
};

// node_modules/gophergfx/src/geometry/2d/Circle.ts
var Circle = class extends Shape {
  constructor(radius = 0.5, numSegments = 50) {
    super();
    this.radius = radius;
    this.material.drawMode = this.gl.TRIANGLE_FAN;
    this.createVertices(this.radius, numSegments);
    this.createTextureCoordinates(numSegments);
    this.createDefaultVertexColors();
  }
  createVertices(radius, numSegments) {
    const vertices = [0, 0];
    const angle = Math.PI * 2 / numSegments;
    for (let i = 0; i <= numSegments; i++) {
      vertices.push(Math.cos(angle * i) * radius, Math.sin(angle * i) * radius);
    }
    this.setVertices(vertices);
  }
  createTextureCoordinates(numSegments) {
    const uvs = [0.5, 0.5];
    const angle = Math.PI * 2 / numSegments;
    for (let i = 0; i <= numSegments; i++) {
      uvs.push((Math.cos(angle * i) + 1) / 2, (Math.sin(angle * i) - 1) / -2);
    }
    this.setTextureCoordinates(uvs);
  }
};

// node_modules/gophergfx/src/geometry/2d/Line.ts
var Line = class extends Shape {
  constructor(startPoint, endPoint, thickness = 0.01) {
    super();
    this.material.drawMode = this.gl.TRIANGLE_STRIP;
    this.createVertices(startPoint.distanceTo(endPoint), thickness);
    this.position = Vector2.add(startPoint, endPoint);
    this.position.divideScalar(2);
    const direction = Vector2.subtract(endPoint, startPoint);
    direction.normalize();
    this.rotation = Vector2.angleBetween(Vector2.RIGHT, direction);
    this.createDefaultVertexColors();
  }
  createVertices(width, height) {
    const vertices = [];
    vertices.push(-width / 2, height / 2);
    vertices.push(-width / 2, -height / 2);
    vertices.push(width / 2, height / 2);
    vertices.push(width / 2, -height / 2);
    this.setVertices(vertices);
  }
};

// node_modules/gophergfx/src/interaction/OrbitControls.ts
var OrbitControls = class {
  constructor(camera, distance = 1, zoomable = true) {
    this.camera = camera;
    this.zoomable = zoomable;
    this.distance = distance;
    this.rotationSpeed = Math.PI / 4;
    this.zoomSpeed = 0.25;
    this.targetPoint = new Vector3();
    this.cameraOrbitX = new Quaternion();
    this.cameraOrbitY = new Quaternion();
    this.rotationDirection = new Vector3();
    this.zoomDirection = 0;
    this.mouseDrag = false;
    window.addEventListener("mousedown", (event) => {
      this.onMouseDown(event);
    });
    window.addEventListener("mouseup", (event) => {
      this.onMouseUp(event);
    });
    window.addEventListener("mousemove", (event) => {
      this.onMouseMove(event);
    });
    window.addEventListener("wheel", (event) => {
      this.onMouseWheel(event);
    });
    this.updateCamera();
  }
  setTargetPoint(targetPoint) {
    this.targetPoint.copy(targetPoint);
    this.updateCamera();
  }
  setDistance(distance) {
    this.distance = distance;
    this.updateCamera();
  }
  setOrbit(orbitX, orbitY) {
    this.cameraOrbitX.setRotationX(orbitX);
    this.cameraOrbitY.setRotationY(orbitY);
    this.updateCamera();
  }
  onMouseDown(event) {
    if (event.target.localName == "canvas")
      this.mouseDrag = true;
  }
  onMouseUp(event) {
    this.mouseDrag = false;
  }
  onMouseMove(event) {
    if (this.mouseDrag) {
      this.rotationDirection.x += -event.movementY;
      this.rotationDirection.y += -event.movementX;
    }
  }
  onMouseWheel(event) {
    if (this.zoomable) {
      this.zoomDirection += event.deltaY;
    }
  }
  update(deltaTime) {
    this.cameraOrbitX.multiply(Quaternion.makeRotationX(this.rotationDirection.x * this.rotationSpeed * deltaTime));
    this.cameraOrbitY.multiply(Quaternion.makeRotationY(this.rotationDirection.y * this.rotationSpeed * deltaTime));
    this.distance += this.zoomDirection * this.zoomSpeed * deltaTime;
    this.rotationDirection.set(0, 0, 0);
    this.zoomDirection = 0;
    this.updateCamera();
  }
  updateCamera() {
    this.camera.rotation.copy(this.cameraOrbitX);
    this.camera.rotation.multiply(this.cameraOrbitY);
    this.camera.position.set(0, 0, this.distance);
    this.camera.position.rotate(this.camera.rotation);
    this.camera.position.add(this.targetPoint);
  }
};

// node_modules/gophergfx/src/interaction/FirstPersonControls.ts
var FirstPersonControls = class {
  constructor(camera) {
    this.camera = camera;
    this.translationSpeed = 2;
    this.rotationSpeed = Math.PI / 4;
    this.moveDirection = new Vector3();
    this.rotationDirection = new Vector3();
    this.mouseDrag = false;
    this.targetOrbitX = new Quaternion();
    this.targetOrbitY = new Quaternion();
    window.addEventListener("mousedown", (event) => {
      this.onMouseDown(event);
    });
    window.addEventListener("mouseup", (event) => {
      this.onMouseUp(event);
    });
    window.addEventListener("mousemove", (event) => {
      this.onMouseMove(event);
    });
    window.addEventListener("keydown", (event) => {
      this.onKeyDown(event);
    });
    window.addEventListener("keyup", (event) => {
      this.onKeyUp(event);
    });
  }
  onMouseDown(event) {
    if (event.target.localName == "canvas")
      this.mouseDrag = true;
  }
  onMouseUp(event) {
    this.mouseDrag = false;
    this.rotationDirection.set(0, 0, 0);
  }
  onMouseMove(event) {
    if (this.mouseDrag) {
      this.rotationDirection.x += -event.movementY;
      this.rotationDirection.y += -event.movementX;
    }
  }
  onKeyDown(event) {
    if (event.key == "w") {
      this.moveDirection.z = -1;
    } else if (event.key == "s") {
      this.moveDirection.z = 1;
    } else if (event.key == "a") {
      this.moveDirection.x = -1;
    } else if (event.key == "d") {
      this.moveDirection.x = 1;
    }
  }
  onKeyUp(event) {
    if (event.key == "w" && this.moveDirection.z == -1) {
      this.moveDirection.z = 0;
    }
    if (event.key == "s" && this.moveDirection.z == 1) {
      this.moveDirection.z = 0;
    } else if (event.key == "a" && this.moveDirection.x == -1) {
      this.moveDirection.x = 0;
    } else if (event.key == "d" && this.moveDirection.x == 1) {
      this.moveDirection.x = 0;
    }
  }
  update(deltaTime) {
    const newTargetOrbitX = Quaternion.multiply(this.targetOrbitX, Quaternion.makeRotationX(this.rotationDirection.x * this.rotationSpeed * deltaTime));
    const testVector = new Vector3(0, 0, -1);
    testVector.rotate(newTargetOrbitX);
    if (testVector.z < 0)
      this.targetOrbitX.copy(newTargetOrbitX);
    this.targetOrbitY.multiply(Quaternion.makeRotationY(this.rotationDirection.y * this.rotationSpeed * deltaTime));
    this.rotationDirection.set(0, 0, 0);
    const target = new Vector3(0, 0, -1);
    target.rotate(this.targetOrbitX);
    target.rotate(this.targetOrbitY);
    target.add(this.camera.position);
    this.camera.lookAt(target, Vector3.UP);
    const moveDirectionNormalized = Vector3.normalize(this.moveDirection);
    moveDirectionNormalized.multiplyScalar(this.translationSpeed * deltaTime);
    this.camera.translate(moveDirectionNormalized);
  }
};

// node_modules/gophergfx/src/lights/Light.ts
var LightType = /* @__PURE__ */ ((LightType2) => {
  LightType2[LightType2["POINT"] = 0] = "POINT";
  LightType2[LightType2["DIRECTIONAL"] = 1] = "DIRECTIONAL";
  return LightType2;
})(LightType || {});
var Light = class extends Transform3 {
  constructor(type = 0 /* POINT */, ambientIntensity = new Color(), diffuseIntensity = new Color(), specularIntensity = new Color()) {
    super();
    this.type = type;
    this.ambientIntensity = ambientIntensity;
    this.diffuseIntensity = diffuseIntensity;
    this.specularIntensity = specularIntensity;
  }
  getType() {
    return this.type;
  }
  setLights(lightManager) {
    lightManager.addLight(this);
    super.setLights(lightManager);
  }
};

// node_modules/gophergfx/src/lights/AmbientLight.ts
var AmbientLight = class extends Light {
  constructor(color = new Color(0.5, 0.5, 0.5)) {
    super(0 /* POINT */, color, new Color(0, 0, 0), new Color(0, 0, 0));
  }
};

// node_modules/gophergfx/src/lights/DirectionalLight.ts
var DirectionalLight = class extends Light {
  constructor(color = new Color(0.5, 0.5, 0.5)) {
    super(1 /* DIRECTIONAL */, new Color(0, 0, 0), color, color);
  }
};

// node_modules/gophergfx/src/lights/PointLight.ts
var PointLight = class extends Light {
  constructor(color = new Color(0.5, 0.5, 0.5)) {
    super(0 /* POINT */, new Color(0, 0, 0), color, color);
  }
};

// node_modules/gophergfx/src/loaders/StringParser.ts
var StringParser = class {
  constructor(data) {
    this.tokens = [];
    this.line = 0;
    this.token = 0;
    const lines = data.split("\n");
    for (let i = 0; i < lines.length; i++) {
      this.tokens.push(lines[i].trim().split(/\s+/));
    }
    for (let i = 0; i < this.tokens.length; i++) {
      if (this.tokens[i].length == 1 && this.tokens[i][0] == "") {
        this.tokens.splice(i, 1);
        i--;
      }
    }
  }
  peek() {
    return this.tokens[this.line][this.token];
  }
  expect(token) {
    if (this.peek() == token) {
      this.readToken();
      return true;
    } else {
      return false;
    }
  }
  consumeLine() {
    this.line++;
    this.token = 0;
  }
  done() {
    return this.line >= this.tokens.length;
  }
  readToken() {
    const nextToken = this.tokens[this.line][this.token];
    this.token++;
    if (this.token >= this.tokens[this.line].length) {
      this.line++;
      this.token = 0;
    }
    return nextToken;
  }
  readNumber() {
    return Number(this.readToken());
  }
  readLine() {
    const nextLine = [];
    for (let i = this.token; i < this.tokens[this.line].length; i++) {
      nextLine.push(this.tokens[this.line][i]);
    }
    this.line++;
    this.token = 0;
    return nextLine;
  }
};

// node_modules/gophergfx/src/loaders/ObjLoader.ts
var ObjLoader = class {
  static load(filename, mesh = null, callback = null) {
    GfxApp.getInstance().assetManager.requestedAssets.push(filename);
    if (!mesh)
      mesh = new Mesh();
    fetch(filename).then((response) => {
      if (!response.ok)
        throw new Error();
      return response.blob();
    }).then((data) => {
      data.text().then((text) => {
        ObjLoader.parse(text, mesh);
        GfxApp.getInstance().assetManager.loadedAssets.push(filename);
        if (callback) {
          callback(mesh);
        }
      });
    }).catch(() => {
      GfxApp.getInstance().assetManager.errorAssets.push(filename);
      console.error("Unable to download file: " + filename);
    });
    return mesh;
  }
  static parse(obj, mesh) {
    const parser = new StringParser(obj);
    const vertices = [];
    const colors = [];
    const normals = [];
    const indices = [];
    while (!parser.done()) {
      const nextToken = parser.readToken();
      if (nextToken == "v")
        this.parseVertex(parser.readLine(), vertices, colors);
      else if (nextToken == "vn")
        this.parseNormal(parser.readLine(), normals);
      else if (nextToken == "f")
        this.parseFace(parser.readLine(), indices);
      else
        parser.consumeLine();
    }
    mesh.setVertices(vertices);
    mesh.setColors(colors);
    mesh.setNormals(normals);
    mesh.setIndices(indices);
    if (colors.length == 0)
      mesh.createDefaultVertexColors();
  }
  static parseVertex(line, vertices, colors) {
    vertices.push(Number(line[0]));
    vertices.push(Number(line[1]));
    vertices.push(Number(line[2]));
    if (line.length == 6) {
      colors.push(Number(line[3]));
      colors.push(Number(line[4]));
      colors.push(Number(line[5]));
      colors.push(1);
    }
  }
  static parseNormal(line, normals) {
    normals.push(Number(line[0]));
    normals.push(Number(line[1]));
    normals.push(Number(line[2]));
  }
  static parseFace(line, indices) {
    for (let i = 0; i < 3; i++) {
      const index = line[i].split("/");
      indices.push(Number(index[0]) - 1);
    }
  }
};

// node_modules/gophergfx/src/materials/Texture.ts
var _Texture = class {
  constructor(url = null) {
    this.gl = GfxApp.getInstance().renderer.gl;
    this.texture = this.gl.createTexture();
    this.id = _Texture.numTextures;
    _Texture.numTextures++;
    this.gl.activeTexture(this.gl.TEXTURE0 + this.id);
    this.gl.bindTexture(this.gl.TEXTURE_2D, this.texture);
    this.gl.texImage2D(
      this.gl.TEXTURE_2D,
      0,
      this.gl.RGBA,
      1,
      1,
      0,
      this.gl.RGBA,
      this.gl.UNSIGNED_BYTE,
      new Uint8Array([255, 0, 255, 255])
    );
    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE);
    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE);
    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR);
    if (url)
      this.load(url);
  }
  load(url) {
    GfxApp.getInstance().assetManager.requestedAssets.push(url);
    const image = new Image();
    image.addEventListener("load", (event) => {
      this.imageLoaded(image, url);
    }, false);
    image.addEventListener("error", (event) => {
      this.imageNotFound(url);
    }, false);
    image.src = url;
  }
  imageLoaded(image, url) {
    GfxApp.getInstance().assetManager.loadedAssets.push(url);
    this.gl.activeTexture(this.gl.TEXTURE0 + this.id);
    this.gl.bindTexture(this.gl.TEXTURE_2D, this.texture);
    this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.gl.RGBA, this.gl.UNSIGNED_BYTE, image);
    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE);
    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE);
    this.gl.generateMipmap(this.gl.TEXTURE_2D);
  }
  imageNotFound(url) {
    GfxApp.getInstance().assetManager.errorAssets.push(url);
  }
};
var Texture = _Texture;
Texture.numTextures = 0;

// node_modules/gophergfx/src/shaders/wireframe.vert
var wireframe_default = "#version 300 es\n\nprecision mediump float;\n\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\n\nin vec3 position;\n\nvoid main() \n{\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1);\n}";

// node_modules/gophergfx/src/shaders/wireframe.frag
var wireframe_default2 = "#version 300 es\n\nprecision mediump float;\n\nuniform vec4 color;\n\nout vec4 fragColor;\n\nvoid main() \n{\n    fragColor = color;\n}";

// node_modules/gophergfx/src/materials/WireframeMaterial.ts
var _WireframeMaterial = class extends Material3 {
  constructor() {
    super();
    this.color = new Color(1, 1, 1, 1);
    this.wireframeBuffers = /* @__PURE__ */ new Map();
    _WireframeMaterial.shader.initialize(this.gl);
    this.positionAttribute = _WireframeMaterial.shader.getAttribute(this.gl, "position");
    this.modelViewUniform = _WireframeMaterial.shader.getUniform(this.gl, "modelViewMatrix");
    this.projectionUniform = _WireframeMaterial.shader.getUniform(this.gl, "projectionMatrix");
    this.colorUniform = _WireframeMaterial.shader.getUniform(this.gl, "color");
  }
  draw(mesh, transform, camera, lightManager) {
    if (!this.visible || mesh.triangleCount == 0)
      return;
    this.initialize();
    this.gl.useProgram(_WireframeMaterial.shader.getProgram());
    this.gl.uniformMatrix4fv(this.modelViewUniform, false, Matrix4.multiply(transform.worldMatrix, camera.viewMatrix).mat);
    this.gl.uniformMatrix4fv(this.projectionUniform, false, camera.projectionMatrix.mat);
    this.gl.uniform4f(this.colorUniform, this.color.r, this.color.g, this.color.b, this.color.a);
    this.gl.enableVertexAttribArray(this.positionAttribute);
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, mesh.positionBuffer);
    this.gl.vertexAttribPointer(this.positionAttribute, 3, this.gl.FLOAT, false, 0, 0);
    if (!this.wireframeBuffers.get(mesh)) {
      this.updateWireframeBuffer(mesh);
    }
    this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.wireframeBuffers.get(mesh));
    this.gl.drawElements(this.gl.LINES, mesh.triangleCount * 6, this.gl.UNSIGNED_SHORT, 0);
  }
  updateWireframeBuffer(mesh) {
    let wireframeBuffer;
    wireframeBuffer = this.wireframeBuffers.get(mesh);
    if (!wireframeBuffer) {
      wireframeBuffer = this.gl.createBuffer();
      if (wireframeBuffer)
        this.wireframeBuffers.set(mesh, wireframeBuffer);
    }
    const indexArray = new Uint16Array(mesh.triangleCount * 3);
    this.gl.bindBuffer(this.gl.COPY_READ_BUFFER, mesh.indexBuffer);
    this.gl.getBufferSubData(this.gl.COPY_READ_BUFFER, 0, indexArray);
    const indices = [...indexArray];
    const wireframeIndices = [];
    for (let i = 0; i < mesh.triangleCount; i++) {
      wireframeIndices.push(indices[i * 3]);
      wireframeIndices.push(indices[i * 3 + 1]);
      wireframeIndices.push(indices[i * 3 + 1]);
      wireframeIndices.push(indices[i * 3 + 2]);
      wireframeIndices.push(indices[i * 3 + 2]);
      wireframeIndices.push(indices[i * 3]);
    }
    this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, wireframeBuffer);
    this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(wireframeIndices), this.gl.STATIC_DRAW);
  }
};
var WireframeMaterial = _WireframeMaterial;
WireframeMaterial.shader = new ShaderProgram(wireframe_default, wireframe_default2);

// node_modules/gophergfx/src/shaders/unlit.vert
var unlit_default = "#version 300 es\n\nprecision mediump float;\n\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\n\nin vec3 position;\nin vec4 color;\nin vec2 texCoord;\n\nout vec4 vertColor;\nout vec2 uv;\n\nvoid main() \n{\n    vertColor = color;\n    uv = texCoord.xy;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1);\n}";

// node_modules/gophergfx/src/shaders/unlit.frag
var unlit_default2 = "#version 300 es\n\nprecision mediump float;\n\nuniform vec4 color;\nuniform int useTexture;\nuniform sampler2D textureImage;\n\nin vec2 uv;\n\nin vec4 vertColor;\nout vec4 fragColor;\n\nvoid main() \n{\n    fragColor = color * vertColor;\n\n    if(useTexture != 0)\n    {\n        fragColor *= texture(textureImage, uv);\n    }\n}";

// node_modules/gophergfx/src/materials/UnlitMaterial.ts
var _UnlitMaterial = class extends Material3 {
  constructor() {
    super();
    this.texture = null;
    this.color = new Color(1, 1, 1);
    _UnlitMaterial.shader.initialize(this.gl);
    this.colorUniform = _UnlitMaterial.shader.getUniform(this.gl, "color");
    this.textureUniform = _UnlitMaterial.shader.getUniform(this.gl, "textureImage");
    this.useTextureUniform = _UnlitMaterial.shader.getUniform(this.gl, "useTexture");
    this.modelViewUniform = _UnlitMaterial.shader.getUniform(this.gl, "modelViewMatrix");
    this.projectionUniform = _UnlitMaterial.shader.getUniform(this.gl, "projectionMatrix");
    this.positionAttribute = _UnlitMaterial.shader.getAttribute(this.gl, "position");
    this.colorAttribute = _UnlitMaterial.shader.getAttribute(this.gl, "color");
    this.texCoordAttribute = _UnlitMaterial.shader.getAttribute(this.gl, "texCoord");
  }
  draw(mesh, transform, camera, lightManager) {
    if (!this.visible || mesh.triangleCount == 0)
      return;
    this.initialize();
    this.gl.useProgram(_UnlitMaterial.shader.getProgram());
    this.gl.uniformMatrix4fv(this.modelViewUniform, false, Matrix4.multiply(transform.worldMatrix, camera.viewMatrix).mat);
    this.gl.uniformMatrix4fv(this.projectionUniform, false, camera.projectionMatrix.mat);
    this.gl.uniform4f(this.colorUniform, this.color.r, this.color.g, this.color.b, this.color.a);
    this.gl.enableVertexAttribArray(this.colorAttribute);
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, mesh.colorBuffer);
    this.gl.vertexAttribPointer(this.colorAttribute, 4, this.gl.FLOAT, false, 0, 0);
    this.gl.enableVertexAttribArray(this.positionAttribute);
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, mesh.positionBuffer);
    this.gl.vertexAttribPointer(this.positionAttribute, 3, this.gl.FLOAT, false, 0, 0);
    if (this.texture) {
      this.gl.uniform1i(this.useTextureUniform, 1);
      this.gl.activeTexture(this.gl.TEXTURE0 + this.texture.id);
      this.gl.bindTexture(this.gl.TEXTURE_2D, this.texture.texture);
      this.gl.uniform1i(this.textureUniform, this.texture.id);
      this.gl.enableVertexAttribArray(this.texCoordAttribute);
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, mesh.texCoordBuffer);
      this.gl.vertexAttribPointer(this.texCoordAttribute, 2, this.gl.FLOAT, false, 0, 0);
    } else {
      this.gl.uniform1i(this.useTextureUniform, 0);
    }
    this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, mesh.indexBuffer);
    this.gl.drawElements(this.gl.TRIANGLES, mesh.triangleCount * 3, this.gl.UNSIGNED_SHORT, 0);
  }
};
var UnlitMaterial = _UnlitMaterial;
UnlitMaterial.shader = new ShaderProgram(unlit_default, unlit_default2);

// node_modules/gophergfx/src/materials/BoundingVolumeMaterial.ts
var BoundingVolumeMode = /* @__PURE__ */ ((BoundingVolumeMode2) => {
  BoundingVolumeMode2[BoundingVolumeMode2["BOX"] = 0] = "BOX";
  BoundingVolumeMode2[BoundingVolumeMode2["SPHERE"] = 1] = "SPHERE";
  BoundingVolumeMode2[BoundingVolumeMode2["NONE"] = 2] = "NONE";
  return BoundingVolumeMode2;
})(BoundingVolumeMode || {});
var BoundingVolumeMaterial = class extends Material3 {
  constructor(mode = 0 /* BOX */, color = new Color(1, 1, 1, 1)) {
    super();
    this.mode = mode;
    this.sphere = new SphereMesh(1, 2);
    this.box = new BoxMesh(1, 1, 1);
    this.wireframeMaterial = new WireframeMaterial();
    this.wireframeMaterial.color.copy(color);
    this.sphere.material = this.wireframeMaterial;
    this.box.material = this.wireframeMaterial;
  }
  draw(mesh, transform, camera, lightManager) {
    if (this.mode == 0 /* BOX */) {
      const boxCenter = Vector3.add(mesh.boundingBox.min, mesh.boundingBox.max);
      boxCenter.multiplyScalar(0.5);
      this.box.position.copy(boxCenter);
      this.box.scale.set(
        mesh.boundingBox.max.x - mesh.boundingBox.min.x,
        mesh.boundingBox.max.y - mesh.boundingBox.min.y,
        mesh.boundingBox.max.z - mesh.boundingBox.min.z
      );
      this.box.parent = mesh;
      this.box.computeWorldTransform();
      this.box.draw(mesh, camera, lightManager);
    } else if (this.mode == 1 /* SPHERE */) {
      this.sphere.position.copy(mesh.boundingSphere.center);
      this.sphere.scale.set(mesh.boundingSphere.radius, mesh.boundingSphere.radius, mesh.boundingSphere.radius);
      this.sphere.parent = mesh;
      this.sphere.computeWorldTransform();
      this.sphere.draw(mesh, camera, lightManager);
    }
  }
};

// node_modules/gophergfx/src/math/Plane.ts
var Plane = class {
  constructor(point = new Vector3(), normal = new Vector3(0, 0, -1)) {
    this.point = point;
    this.normal = normal;
  }
};

// node_modules/gophergfx/src/math/Ray.ts
var Ray = class {
  constructor(origin = new Vector3(), direction = new Vector3(0, 0, -1)) {
    this.origin = origin;
    this.direction = direction;
  }
  set(origin, direction) {
    this.origin = origin;
    this.direction = direction;
  }
  setPickRay(deviceCoords, camera) {
    this.origin.copy(camera.worldPosition);
    this.direction.set(deviceCoords.x, deviceCoords.y, -1);
    this.direction.applyMatrix(camera.projectionMatrix.inverse());
    this.direction.rotate(camera.worldRotation);
    this.direction.normalize();
  }
  intersectsPlane(plane) {
    const denominator = this.direction.dot(plane.normal);
    if (Math.abs(denominator) > 1e-6) {
      const rayOriginToPlanePoint = Vector3.subtract(plane.point, this.origin);
      const t = rayOriginToPlanePoint.dot(plane.normal) / denominator;
      if (t > 0) {
        const intersectionPoint = Vector3.multiplyScalar(this.direction, t);
        intersectionPoint.add(this.origin);
        return intersectionPoint;
      }
    }
    return null;
  }
  intersectsSphere(sphere) {
    const l = Vector3.subtract(sphere.center, this.origin);
    const tca = l.dot(this.direction);
    const radiusSquared = sphere.radius * sphere.radius;
    const d2 = l.dot(l) - tca * tca;
    if (d2 > radiusSquared)
      return null;
    const thc = Math.sqrt(radiusSquared - d2);
    const t0 = tca - thc;
    const t1 = tca + thc;
    if (t0 < 0 && t1 < 0)
      return null;
    const intersection = this.direction.clone();
    if (t0 < t1)
      intersection.multiplyScalar(t0);
    else
      intersection.multiplyScalar(t1);
    intersection.add(this.origin);
    return intersection;
  }
  intersectsBox(box) {
    let tmin = (box.min.x - this.origin.x) / this.direction.x;
    let tmax = (box.max.x - this.origin.x) / this.direction.x;
    if (tmin > tmax) {
      const temp = tmin;
      tmin = tmax;
      tmax = temp;
    }
    let tymin = (box.min.y - this.origin.y) / this.direction.y;
    let tymax = (box.max.y - this.origin.y) / this.direction.y;
    if (tymin > tymax) {
      const temp = tymin;
      tymin = tymax;
      tymax = temp;
    }
    if (tmin > tymax || tymin > tmax)
      return null;
    if (tymin > tmin)
      tmin = tymin;
    if (tymax < tmax)
      tmax = tymax;
    let tzmin = (box.min.z - this.origin.z) / this.direction.z;
    let tzmax = (box.max.z - this.origin.z) / this.direction.z;
    if (tzmin > tzmax) {
      const temp = tzmin;
      tzmin = tzmax;
      tzmax = temp;
    }
    if (tmin > tzmax || tzmin > tmax)
      return null;
    if (tzmin > tmin)
      tmin = tzmin;
    if (tzmax < tmax)
      tmax = tzmax;
    const intersectionPoint = Vector3.multiplyScalar(this.direction, tmin);
    intersectionPoint.add(this.origin);
    return intersectionPoint;
  }
  intersectsMeshBoundingBox(mesh) {
    const localIntersection = this.createLocalRay(mesh).intersectsBox(mesh.boundingBox);
    if (localIntersection) {
      localIntersection.multiply(mesh.worldScale);
      localIntersection.rotate(mesh.worldRotation);
      localIntersection.add(mesh.worldPosition);
    }
    return localIntersection;
  }
  intersectsMeshBoundingSphere(mesh) {
    const localIntersection = this.createLocalRay(mesh).intersectsSphere(mesh.boundingSphere);
    if (localIntersection) {
      localIntersection.multiply(mesh.worldScale);
      localIntersection.rotate(mesh.worldRotation);
      localIntersection.add(mesh.worldPosition);
    }
    return localIntersection;
  }
  intersectsMesh(mesh) {
    if (!this.intersectsMeshBoundingBox(mesh))
      return null;
    const vertices = mesh.getVertices();
    const indices = mesh.getIndices();
    const localRay = this.createLocalRay(mesh);
    const results = [];
    for (let i = 0; i < indices.length; i += 3) {
      const intersection = this.intersectsTriangle(
        localRay,
        new Vector3(vertices[indices[i] * 3], vertices[indices[i] * 3 + 1], vertices[indices[i] * 3 + 2]),
        new Vector3(vertices[indices[i + 1] * 3], vertices[indices[i + 1] * 3 + 1], vertices[indices[i + 1] * 3 + 2]),
        new Vector3(vertices[indices[i + 2] * 3], vertices[indices[i + 2] * 3 + 1], vertices[indices[i + 2] * 3 + 2])
      );
      if (intersection) {
        intersection.multiply(mesh.worldScale);
        intersection.rotate(mesh.worldRotation);
        intersection.add(mesh.worldPosition);
        results.push(intersection);
      }
    }
    if (results.length == 0) {
      return null;
    } else {
      let closestPoint = 0;
      let closestDistance = this.origin.distanceTo(results[0]);
      for (let i = 1; i < results.length; i++) {
        const distance = this.origin.distanceTo(results[i]);
        if (distance < closestDistance) {
          closestPoint = i;
          closestDistance = distance;
        }
      }
      return results[closestPoint];
    }
  }
  intersectsTriangle(ray, vertex0, vertex1, vertex2) {
    const EPSILON = 1e-7;
    const edge1 = Vector3.subtract(vertex1, vertex0);
    const edge2 = Vector3.subtract(vertex2, vertex0);
    const h = Vector3.cross(ray.direction, edge2);
    const a = edge1.dot(h);
    if (a > -EPSILON && a < EPSILON) {
      return null;
    }
    const f = 1 / a;
    const s = Vector3.subtract(ray.origin, vertex0);
    const u = f * s.dot(h);
    if (u < 0 || u > 1) {
      return null;
    }
    const q = Vector3.cross(s, edge1);
    const v = f * ray.direction.dot(q);
    if (v < 0 || u + v > 1) {
      return null;
    }
    const t = f * edge2.dot(q);
    if (t > EPSILON) {
      const intersection = ray.direction.clone();
      intersection.multiplyScalar(t);
      intersection.add(ray.origin);
      return intersection;
    }
    return null;
  }
  createLocalRay(transform) {
    const localRay = new Ray(this.origin.clone(), this.direction.clone());
    localRay.origin.subtract(transform.worldPosition);
    const inverseRotation = transform.worldRotation.inverse();
    localRay.origin.rotate(inverseRotation);
    localRay.direction.rotate(inverseRotation);
    const scale = transform.worldScale;
    const inverseScale = new Vector3();
    inverseScale.x = 1 / scale.x;
    inverseScale.y = 1 / scale.y;
    inverseScale.z = 1 / scale.z;
    localRay.origin.multiply(inverseScale);
    localRay.direction.multiply(inverseScale);
    localRay.direction.normalize();
    return localRay;
  }
};
export {
  AmbientLight,
  AssetManager,
  BoundingBox2,
  BoundingBox3,
  BoundingCircle,
  BoundingSphere,
  BoundingVolumeMaterial,
  BoundingVolumeMode,
  BoxMesh,
  Camera,
  Circle,
  Color,
  DirectionalLight,
  FirstPersonControls,
  GfxApp,
  GouraudMaterial,
  IntersectionMode2,
  Light,
  LightManager,
  LightType,
  Line,
  Material2,
  Material3,
  MathUtils,
  Matrix4,
  Mesh,
  MeshInstance,
  ObjLoader,
  OrbitControls,
  Plane,
  PlaneMesh,
  PointLight,
  Quaternion,
  Ray,
  Rectangle,
  Renderer,
  Scene,
  ShaderProgram,
  Shape,
  ShapeInstance,
  Side,
  SphereMesh,
  StringParser,
  Texture,
  Transform2,
  Transform3,
  UnlitMaterial,
  Vector2,
  Vector3,
  Viewport,
  WireframeMaterial
};
//# sourceMappingURL=gophergfx.js.map
